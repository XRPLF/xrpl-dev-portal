<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">

    <title>rippled - Ripple Developer Portal</title>

    <!-- favicon -->
    <link rel="icon" href="favicon.ico" type="image/x-icon"> 
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">

    <!-- jQuery -->
    <script src="vendor/jquery-1.11.1.min.js"></script>

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <script src="js/bootstrap.min.js"></script>


    <!-- Flatdoc theme -->
    <link  href='vendor/flatdoc/v/0.8.0/theme-white/style.css' rel='stylesheet'>
    <script src="vendor/flatdoc/v/0.8.0/theme-white/script.js"></script>

    <!-- syntax highlighting -->
    <link rel="stylesheet" href="vendor/docco.min.css">
    <script src="vendor/highlight.min.js"></script>

    <!-- syntax selection js -->
    <script src="js/multicodetab.js"></script>
    <!-- Markdown content already parsed+included; just do the code tab stuff -->
    <script>
        $(document).ready(function() {
            $().multicode_tabs_pandoc();
            hljs.initHighlighting();
            make_code_expandable();
        });
    </script>

    <script src="js/expandcode.js"></script>
    <script src="js/fixsidebarscroll.js"></script>
    
    <!-- Custom Stylesheets -->
    <link href="font/fonts.css" rel="stylesheet" type="text/css" />
    <link href="css/main.css" rel="stylesheet" />
    <link href="css/custom.css" rel="stylesheet" />
    
    <link rel="shortcut icon" href="favicon.ico?v=2" type="image/x-icon" />
    <link rel="icon" href="favicon.ico?v=2" type="image/x-icon" />
    
  
</head>
<body  class='no-literate'>
 	<div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="./"><img class="small_logo" src="assets/img/ripple_logo_small.png"></a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Concepts <span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                    <li><a href="paths.html">Paths</a></li>
                    <li><a href="fees.html">Fees (Disambiguation)</a></li>
                    <li><a href="transfer_fees.html">Transfer Fees</a></li>
                    <li><a href="tx-cost.html">Transaction Cost</a></li>
                    <li><a href="fee-voting.html">Fee Voting</a></li>
                    <li><a href="reserves.html">Reserves</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">References <span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                    <li><a href="rippled-apis.html">rippled</a></li>
                    <li><a href="ripple-rest.html">Ripple-REST</a></li>
                    <li><a href="transactions.html">Transactions</a></li>
                    <li><a href="ripple-ledger.html">Ripple Consensus Ledger</a></li>
                    <li><a href="historical_data.html">Historical Data API</a></li>
                    <li><a href="charts_api.html">Ripple Charts API</a></li>
                    <li><a href="data_api_v2.html">Ripple Data API v2</a></li>
                    <li><a href="rippleapi.html">RippleAPI</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Tutorials <span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                    <li><a href="rippled-setup.html">rippled Setup</a></li>
                    <li><a href="reliable_tx.html">Reliable Transaction Submission</a></li>
                    <li><a href="gateway_guide.html">Gateway Guide</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">API Tools <span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                    <li><a href="rest-api-tool.html">Ripple-REST API Tool</a></li>
                    <li><a href="historicaldb-api-tool.html">Historical Database API Tool</a></li>
                    <li><a href="ripple-api-tool.html">WebSocket API Tool</a></li>
                    <li><a href="charts-api-tool.html">Charts API Tool</a></li>
                    <li><a href="data-api-v2-tool.html">Data API v2 Tool</a></li>
              </ul>
            </li>
            <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Resources <span class="caret"></span></a>
                <ul class="dropdown-menu" role="menu">
					<li><a href="https://forum.ripple.com/viewforum.php?f=2">Forums</a></li>
                    <li><a href="https://www.bountysource.com/teams/ripple/bounties">Bounties</a></li>
                    <li><a href="https://ripplelabs.atlassian.net/">Bug Tracking</a></li>
					<li><a href="https://ripple.com/category/dev-blog/">Dev Blog</a></li>
				    <li><a href="https://ripple.com/press-releases/">Press Center</a></li>
                    <li><a href="https://ripple.com/brand-guidelines/">Brand Guidelines</a></li>
				</ul>
                <li><a href="https://github.com/ripple/ripple-dev-portal" title="GitHub">Site Source</a></li>
            </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <script type="text/javascript">
    if (window.location.host.indexOf("github.io") > -1) {
        document.write("<div style='background-color:red; color:white; position:fixed; top: 50px; right: 150px; padding: 10px 20px;'>DRAFT</div>");
    }
    </script>
    <div class='wrapper'>
    <div class='content-root'>
        <div class='menubar'>
            <div class='menu section' role='flatdoc-menu'>
                <script type="text/javascript" src="js/jquery.gensidebar.js"></script>
                <script type="text/javascript">

                </script>
            </div>
        </div>
        <div class='content'>
	        <h1 id="rippled">rippled</h1>
<p>The core peer-to-peer server that operates the Ripple Network is called <code>rippled</code>. Each <code>rippled</code> server connects to the Ripple Network, relays cryptographically signed transactions, and maintains a local copy of the complete shared global ledger. The source code for <code>rippled</code> is written in C++, and is <a href="https://github.com/ripple/rippled">available on GitHub under an open-source license</a>.</p>
<ul>
<li><a href="rippled-setup.html"><code>rippled</code> Setup</a></li>
<li><a href="#api-methods">API Reference</a></li>
<li><a href="transactions.html">Transaction Reference</a></li>
<li>Client Library - <a href="https://github.com/ripple/ripple-lib">Javascript</a></li>
</ul>
<h1 id="websocket-and-json-rpc-apis">WebSocket and JSON-RPC APIs</h1>
<p>If you want to communicate directly with the <code>rippled</code> server, you can use either the WebSocket API or the JSON-RPC API. Both APIs use the same list of commands, with almost entirely the same parameters in each command. Whereas the <a href="ripple-rest.html">Ripple-REST API</a> provides a simplified interface on top of the WebSocket API for easier integration, these APIs provide the full power of Ripple but require slightly more complexity:</p>
<ul>
<li>The WebSocket API uses the <a href="http://www.html5rocks.com/en/tutorials/websockets/basics/">WebSocket protocol</a>, available in most browsers and Javascript implementations, to achieve persistent two-way communication. There is not a 1:1 correlation between requests and responses. Some requests prompt the server to send multiple messages back asynchronously; other times, responses may arrive in a different order than the requests that prompted them. The <code>rippled</code> server can be configured to accept secured (wss:), unsecured (ws:) WebSocket connections, or both.</li>
<li>The JSON-RPC API relies on simple request-response communication via HTTP or HTTPS. (The <code>rippled</code> server can be configured to accept HTTP, HTTPS, or both.) For commands that prompt multiple responses, you can provide a callback URL.</li>
<li>The <code>rippled</code> program can also be used as a quick commandline client to make JSON-RPC requests to a running <code>rippled</code> server. This is only intended for administrative purposes, and is not a supported API.</li>
</ul>
<p>In general, we recommend using WebSocket, because WebSocket's push paradigm has less latency and less network overhead. JSON-RPC must open and close an HTTP connection for each individual message. WebSocket is also more reliable; you can worry less about missing messages and establishing multiple connections. However, all three have valid use cases and will continue to be supported for the foreseeable future.</p>
<h2 id="changes-to-the-apis">Changes to the APIs</h2>
<p>The WebSocket and JSON-RPC APIs are still in development, and are subject to change. If you want to be notified of upcoming changes and future versions of <code>rippled</code>, subscribe to the Ripple Server mailing list:</p>
<p><a href="https://groups.google.com/forum/#!forum/ripple-server">https://groups.google.com/forum/#!forum/ripple-server</a></p>
<h2 id="connecting-to-rippled">Connecting to rippled</h2>
<p>Before you can run any commands against a <code>rippled</code> server, you must know which server you are connecting to. Most servers are configured not to accept requests directly from the outside network. </p>
<p>Alternatively, you can <a href="rippled-setup.html">run your own local copy of <code>rippled</code></a>. This is required if you want to access any of the <a href="#list-of-admin-commands">Admin Commands</a>. In this case, you should use whatever IP and port you configured the server to bind. (For example, <code>127.0.0.1:54321</code>) Additionally, in order to access admin functionality, you must connect from a port/IP address marked as admin in the config file.</p>
<p>The <a href="https://github.com/ripple/rippled/blob/d7def5509d8338b1e46c0adf309b5912e5168af0/doc/rippled-example.cfg#L831-L854">example config file</a> listens for connections on the local loopback network (127.0.0.1), with JSON-RPC (HTTP) on port 5005 and WebSocket (WS) on port 6006, and treats all connected clients as admin.</p>
<h3 id="websocket-api">WebSocket API</h3>
<p>If you are just looking to try out some methods on the Ripple network, you can skip writing your own WebSocket code and go straight to using the API at the <a href="ripple-api-tool.html">Ripple WebSocket API Tool</a>. Later on, when you want to connect to your own <code>rippled</code> server, you can build your own client in Javascript to run in a browser (See <a href="http://www.websocket.org/echo.html">this example</a> ) or possibly <a href="https://github.com/einaros/ws">Node.js</a>.</p>
<p>Currently Ripple Labs maintains a set of public WebSocket servers at:</p>
<table>
<thead>
<tr>
<th>Domain</th>
<th>Port</th>
</tr>
</thead>
<tbody>
<tr>
<td>s1.ripple.com</td>
<td>443</td>
</tr>
</tbody>
</table>
<p>These public servers are not for sustained or business use, and they may become unavailable at any time. For regular use, you should run your own <code>rippled</code> server or contract someone you trust to do so.</p>
<h3 id="json-rpc">JSON-RPC</h3>
<p>You can use any HTTP client (like <a href="https://addons.mozilla.org/en-US/firefox/addon/poster/">Poster for Firefox</a> or <a href="https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en">Postman for Chrome</a>) to make JSON-RPC calls a <code>rippled</code> server. </p>
<p>Currently, Ripple Labs maintains a set of public JSON-RPC servers at:</p>
<table>
<thead>
<tr>
<th>Domain</th>
<th>Port</th>
</tr>
</thead>
<tbody>
<tr>
<td>s1.ripple.com</td>
<td>51234</td>
</tr>
</tbody>
</table>
<p>These public servers are not for sustained or business use, and they may become unavailable at any time. For regular use, you should run your own <code>rippled</code> server or contract someone you trust to do so.</p>
<h3 id="commandline">Commandline</h3>
<p>The commandline interface connects to the same service as the JSON-RPC one, so the public servers and server configuration are the same. As a commandline client, <code>rippled</code> connects to the local instance. For example:</p>
<pre><code>rippled --conf=/etc/rippled.cfg server_info
</code></pre>
<h2 id="request-formatting">Request Formatting</h2>
<p>Both the WebSocket API and the JSON-RPC API use <a href="http://www.w3schools.com/json/">JSON</a> for requests and responses. The methods and parameters available on both APIs are generally the same, but the exact formatting is slightly different between the two. The commandline interface supports the same commands, with the parameters in the commandline as well.</p>
<ul>
<li>A WebSocket request puts the command name in the <code>"command"</code> field alongside the command's parameters at the top level of the JSON object, with an optional <code>"id"</code> field that will be returned with the response, so you can identify responses that come back out of order. </li>
<li>A JSON-RPC request puts the command in the <code>"method"</code> field, with parameters in a separate object, as the first member of a <code>"params"</code> array. There is no <code>"id"</code> field, since all responses are direct replies to the requests.</li>
<li>The commandline puts the command after any normal (dash-prefaced) commandline options, followed by a limited set of parameters, separated by spaces. </li>
</ul>
<h4 id="example-request">Example Request</h4>
<div class="multicode">

*WebSocket*


wzxhzdk:1


*JSON-RPC*


wzxhzdk:2


*Commandline*


wzxhzdk:3


</div>
<h2 id="response-formatting">Response Formatting</h2>
<h4 id="example-successful-response">Example Successful Response</h4>
<div class="multicode">

*WebSocket*

wzxhzdk:4


*JSON-RPC*

wzxhzdk:5

*Commandline*

wzxhzdk:6


</div>
<p>The fields of a successful response include:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id</code></td>
<td>(Varies)</td>
<td>(WebSocket only) ID provided in the request that prompted this response</td>
</tr>
<tr>
<td><code>status</code> (WebSocket) &lt;br&gt; <code>result.status</code> (JSON-RPC and Commandline)</td>
<td>String</td>
<td><code>"success"</code> if the request successfully completed. In the WebSocket API responses, this is included at the top level; in JSON-RPC and Commandline responses, this is included as a sub-field of the <code>"result"</code> object.</td>
</tr>
<tr>
<td><code>type</code></td>
<td>String</td>
<td>(WebSocket only) Typically <code>"response"</code>, which indicates a successful response to a command. Asynchronous notifications use a different value such as <code>"ledgerClosed"</code> or <code>"transaction"</code>.</td>
</tr>
<tr>
<td><code>result</code></td>
<td>Object</td>
<td>The result of the query; contents vary depending on the command.</td>
</tr>
</tbody>
</table>
<h4 id="commandline-1">Commandline</h4>
<p>The response format for commandline methods is identical to JSON-RPC responses, because they use the same interface.</p>
<h2 id="error-responses">Error Responses</h2>
<p>It is impossible to enumerate all the possible ways an error can occur. Some may occur in the transport layer (for example, loss of network connectivity), in which case the results will vary depending on what client and transport you are using. However, if the <code>rippled</code> server successfully receives your request, it will try to respond in a standardized error format.</p>
<p>Some example errors:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:7


*JSON-RPC*

wzxhzdk:8


*Commandline*

wzxhzdk:9


</div>
<h4 id="websocket-api-error-response-format">WebSocket API Error Response Format</h4>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>(Varies)</td>
<td>ID provided in the Web Socket request that prompted this response</td>
</tr>
<tr>
<td>status</td>
<td>String</td>
<td><code>"error"</code> if the request caused an error</td>
</tr>
<tr>
<td>type</td>
<td>String</td>
<td>Typically <code>"response"</code>, which indicates a successful response to a command.</td>
</tr>
<tr>
<td>error</td>
<td>String</td>
<td>A unique code for the type of error that occurred</td>
</tr>
<tr>
<td>request</td>
<td>Object</td>
<td>A copy of the request that prompted this error, in JSON format. <strong><em>Caution:</em></strong> If the request contained any account secrets, they are copied here!</td>
</tr>
</tbody>
</table>
<h4 id="json-rpc-api-error-response-format">JSON-RPC API Error Response Format</h4>
<p>Some JSON-RPC requests will respond with an error code on the HTTP layer. In these cases, the response is a plain-text explanation in the response body. For example, if you forgot to specify the command in the <code>method</code> parameter, the response is like this:</p>
<pre><code>HTTP Status: 400 Bad Request
Null method
</code></pre>
<p>For other errors that returned with HTTP status code 200 OK, the responses are formatted in JSON, with the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>result</td>
<td>Object</td>
<td>Object containing the response to the query</td>
</tr>
<tr>
<td>result.error</td>
<td>String</td>
<td>A unique code for the type of error that occurred</td>
</tr>
<tr>
<td>result.status</td>
<td>String</td>
<td><code>"error"</code> if the request caused an error</td>
</tr>
<tr>
<td>result.request</td>
<td>Object</td>
<td>A copy of the request that prompted this error, in JSON format. <strong><em>Caution:</em></strong> If the request contained any account secrets, they are copied here! <strong><em>Note:</em></strong> The request is re-formatted in WebSocket format, regardless of the request made. This may be changed in the future: See <a href="https://ripplelabs.atlassian.net/browse/RIPD-279">RIPD-279</a>.</td>
</tr>
</tbody>
</table>
<h3 id="caution-on-errors">Caution on Errors</h3>
<p>When your request results in an error, the entire request is copied back as part of the response, so that you can try to debug the error. However, this also includes any secrets that were passed as part of the request. When sharing error messages, be very careful not to accidentally expose important account secrets to others.</p>
<h3 id="universal-errors">Universal Errors</h3>
<p>All methods can potentially return any of the following values for the <code>error</code> code:</p>
<ul>
<li><code>unknownCmd</code> - The request does not contain a <a href="#api-methods">command</a> that the <code>rippled</code> server recognizes.</li>
<li>`jsonInvalid1 - (WebSocket only) The request is not a proper JSON object. <ul>
<li>JSON-RPC returns a 400 Bad Request HTTP error in this case instead.</li>
</ul>
</li>
<li><code>missingCommand</code> - (WebSocket only) The request did not specify a <code>command</code> field.<ul>
<li>JSON-RPC returns a 400 Bad Request HTTP error in this case instead.</li>
</ul>
</li>
<li><code>tooBusy</code> - The server is under too much load to perform this command right now. Generally not returned if you are connected as an admin.</li>
<li><code>noNetwork</code> - The server is having trouble connecting to the rest of the Ripple Network (and is not running in stand-alone mode).</li>
<li><code>noCurrent</code> - The server does not know what the current ledger is, due to high load, network problems, validator failures, incorrect configuration, or some other problem.</li>
<li><code>noClosed</code> - The server does not have a closed ledger, typically because it has not finished starting up.</li>
<li><code>wsTextRequired</code> - (WebSocket only) The request's <a href="https://tools.ietf.org/html/rfc6455#section-5.2">opcode</a> is not text. </li>
</ul>
<h2 id="formatting-conventions">Formatting Conventions</h2>
<p>The WebSocket and JSON-RPC APIs generally take the same arguments, although they're provided in a different way (See <a href="#request-formatting">Request Formatting</a> for details). Many similar parameters appear throughout the APIs, and there are conventions for how to specify these parameters.</p>
<p>All field names are case-sensitive. In responses, fields that are taken directly from Ledger Node or Transaction objects start with upper-case letters. Other fields, including ones that are dynamically generated for a response, are lower case.</p>
<h3 id="unique-identifiers">Unique Identifiers</h3>
<p>Different types of objects are uniquely identified in different ways:</p>
<p><em>Accounts</em> are identified by their <em>address</em>, a <a href="https://wiki.ripple.com/Encodings">base-58-encoded</a> string, for example <code>"r9cZA1mLK5R5Am25ArfXFmqgNwjZgnfk59"</code>. Addresses always start with "r". You can also provide an un-encoded hex representation instead.</p>
<p><em>Transactions</em> are identified by their <em>hash</em>, which is a <a href="http://en.wikipedia.org/wiki/Sha512">SHA-512</a> hash of the transaction's binary format. Transaction hashes are represented as hex strings.</p>
<p>Each instance of the Ripple <em>Ledger</em> has a sequence number and a hash value. See <a href="#specifying-a-ledger-instance">Specifying a Ledger Instance</a> for details.</p>
<h3 id="specifying-a-ledger-instance">Specifying a Ledger Instance</h3>
<p>Many API methods require you to specify an instance of the ledger, with the data retrieved being considered accurate and up-to-date as of that particular version of the shared ledger. The commands that accept a ledger version all work the same way. There are three ways you can specify which ledger you want to use:</p>
<ol>
<li>Specify a ledger by its Sequence Number in the <code>ledger_index</code> parameter. Each closed ledger has an identifying sequence number that is 1 higher than the previously-validated ledger. (The Genesis Ledger has sequence number 0)</li>
<li>Specify a ledger by its hash value in the <code>ledger_hash</code> parameter. </li>
<li>Specify a ledger by one of the following shortcuts, in the <code>ledger_index</code> parameter:<ul>
<li><code>validated</code> for the most recent ledger that has been validated by the whole network</li>
<li><code>closed</code> for the most recent ledger that has been closed for modifications and proposed for validation by the node</li>
<li><code>current</code> for the node's current working version of the ledger.</li>
</ul>
</li>
</ol>
<p>There is also a deprecated <code>ledger</code> parameter which accepts any of the above three formats. <em>Do not</em> use this parameter; it may be removed without further notice.</p>
<p>If you do not specify a ledger, the <code>current</code> (in-progress) ledger will be chosen by default. If you provide more than one field specifying ledgers, the deprecated <code>ledger</code> field will be used first if it exists, falling back to <code>ledger_hash</code>. The <code>ledger_index</code> field is ignored unless neither of the other two are present. <strong><em>Note:</em></strong> Do not rely on this default behavior; it is subject to change. Instead, you should always specify a ledger version in each call.</p>
<p>The sequence number indicates the order of the ledgers; the hash value identifies the exact contents of the ledger. Two ledgers with the same hash are always identical. For closed ledgers, hash values and sequence numbers are equally valid and correlate 1:1. However, this is not true for in-progress ledgers:</p>
<ul>
<li>Two different rippled servers may have different contents for a current ledger with the same sequence number, due to transactions not being fully propagated throughout the network.</li>
<li>A current ledger's contents change over time, which would cause its hash to change, even though its sequence number stays the same. Therefore, the hash of a ledger is not calculated until it is closed.</li>
</ul>
<h3 id="specifying-currency-amounts">Specifying Currency Amounts</h3>
<p>Some API methods require you to specify an amount of currency. Depending on whether you are dealing in the network's native XRP currency or other currency units (sometimes referred to as IOUs), the style for specifying it is very different.</p>
<h4 id="xrp">XRP</h4>
<p>Amounts of XRP are represented as strings. (JSON integers are limited to 32 bits, so integer overflows are possible.) XRP is formally specified in "drops", which are equivalent to 0.000001 (one 1-millionth) of an XRP each. Thus, to represent 1.0 XRP in a JSON document, you would write:</p>
<pre><code>"1000000"
</code></pre>
<p><strong>Do not specify XRP as an object.</strong></p>
<p>Unit tests are permitted to submit values of XRP (not drops) with a decimal point - for example, "1.23" meaning 1.23 XRP. All other cases should always specify XRP in drops, with no decimal point: e.g. "1230000" meaning 1.23 XRP.</p>
<h4 id="non-xrp">Non-XRP</h4>
<p>If you are specifying non-XRP currency (including fiat dollars, precious metals, cryptocurrencies, or other custom currency) you must specify it with a currency specification object. This is a JSON object with three fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>currency</td>
<td>String</td>
<td>3-character currency code. We recommend using uppercase <a href="http://www.xe.com/iso4217.php">ISO 4217 Currency Codes</a> only. The string <code>"XRP"</code> is disallowed. The following characters are permitted: all uppercase and lowercase letters, digits, as well as the symbols <code>?</code>, <code>!</code>, <code>@</code>, <code>#</code>, <code>$</code>, <code>%</code>, <code>^</code>, <code>&amp;</code>, <code>*</code>, <code>&lt;</code>, <code>&gt;</code>, <code>(</code>, <code>)</code>, <code>{</code>, <code>}</code>, <code>[</code>, <code>]</code>, and <code>|</code>. Instead of a 3-character code, this field could also be a 40-character hex value according to the internal <a href="https://wiki.ripple.com/Currency_format">Currency format</a>.</td>
</tr>
<tr>
<td>value</td>
<td>String</td>
<td>Quoted decimal representation of the amount of currency</td>
</tr>
<tr>
<td>issuer</td>
<td>String</td>
<td>Unique account address of the entity issuing the currency. In other words, the person or business where the currency can be redeemed.</td>
</tr>
</tbody>
</table>
<p>For example, to represent $153.75 US dollars issued by account <code>r9cZA1mLK5R5Am25ArfXFmqgNwjZgnfk59</code>, you would specify:</p>
<pre><code>{
    "currency": "USD",
    "value": "153.75",
    "issuer": "r9cZA1mLK5R5Am25ArfXFmqgNwjZgnfk59"
}
</code></pre>
<p>Unit tests are permitted to submit amounts of non-XRP currencies as a slash-separated string in the format <code>"amount/currency/issuer"</code>. All other cases should use the JSON object format above.</p>
<h4 id="specifying-currencies-without-amounts">Specifying Currencies Without Amounts</h4>
<p>If you are specifying a non-XRP currency without an amount (typically for defining an order book of currency exchange offers) you should specify it as above, but omit the <code>value</code> field.</p>
<p>If you are specifying XRP without an amount (typically for defining an order book) you should specify it as a JSON object with <em>only</em> a <code>currency</code> field. Never include an <code>issuer</code> field for XRP.</p>
<p>Finally, if you are specifying a non-currency for a payment or path definition, and the recipient account of the payment trusts multiple gateways that issue the same currency, you can indicate that the payment should be made in any combination of issuers that the recipient accepts. To do this, specify the recipient account's address as the <code>issuer</code> value in the JSON object.</p>
<h3 id="specifying-time">Specifying Time</h3>
<p>The <code>rippled</code> server and its APIs represent time as an unsigned integer. This number measures the number of seconds since the "Ripple Epoch" of January 1, 2000 (00:00 UTC). This is similar to the way the <a href="http://en.wikipedia.org/wiki/Unix_time">Unix epoch</a> works, except the Ripple Epoch is 946684800 seconds after the Unix Epoch.</p>
<p>Don't convert Ripple Epoch times to UNIX Epoch times in 32-bit variables: this could lead to integer overflows.</p>
<h3 id="possible-server-states">Possible Server States</h3>
<p>Depending on how the <code>rippled</code> server is configured, how long it has been running, and other factors, a server may be participating in the global Ripple Network to different degrees. This is represented as the <code>server_state</code> field in the responses to the <a href="#server-info"><code>server_info</code></a> and <a href="#server-state"><code>server_state</code></a> commands. The possible responses follow a range of ascending interaction, with each subsequent value superseding the previous one. Their definitions are as follows (in order of increasing priority):</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>disconnected</td>
<td>The server is not connected to the Ripple Network whatsoever. It may be running in offline mode, or it may not be able to access the network for whatever reason.</td>
</tr>
<tr>
<td>connected</td>
<td>The server believes it is connected to the network.</td>
</tr>
<tr>
<td>syncing</td>
<td>The server is currently behind on ledger versions. (It is normal for a server to spend a few minutes catching up after you start it.)</td>
</tr>
<tr>
<td>tracking</td>
<td>The server is in agreement with the network</td>
</tr>
<tr>
<td>full</td>
<td>The server is fully caught-up with the network and could participate in validation, but is not doing so (possibly because it has not been configured as a validator).</td>
</tr>
<tr>
<td>validating</td>
<td>The server is currently participating in validation of the ledger</td>
</tr>
<tr>
<td>proposing</td>
<td>The server is participating in validation of the ledger and currently proposing its own version.</td>
</tr>
</tbody>
</table>
<p><strong><em>Note:</em></strong> The distinction between <code>full</code>, <code>validating</code>, and <code>proposing</code> is based on synchronization with the rest of the global network, and it is normal for a server to fluctuate between these states as a course of general operation.</p>
<h3 id="markers-and-pagination">Markers and Pagination</h3>
<p>Some methods return more data than can efficiently fit into one response. When there are more results than contained, the response includes a <code>marker</code> field. You can use this to retrieve more pages of data across multiple calls. In each subsequent request, pass the <code>marker</code> value from the previous response in order to resume from the point where you left off. If the <code>marker</code> is omitted from a response, then you have reached the end of the data set.</p>
<p>The format of the <code>marker</code> field is intentionally undefined. Each server can define a <code>marker</code> field as desired, so it may take the form of a string, a nested object, or another type. Different servers, and different methods provided by the same server, can have different <code>marker</code> definitions. Each <code>marker</code> is ephemeral, and may not work as expected after 10 minutes.</p>
<h2 id="modifying-the-ledger">Modifying the Ledger</h2>
<p>All changes to Ripple's global shared ledger happen as the result of transactions. Consequently, this means that there is <em>only one</em> public API method that causes a change in the state of the Ripple Network at all: the <a href="#submit"><em>submit</em></a> command. Most of the other methods represent different ways to view the data represented in the Ripple Network, and the remaining ones just generate data for your convenience. (The <a href="#wallet-propose">wallet_propose</a>, <a href="#path-find">path_find</a>, and <a href="#random">random</a> commands fall into this category.)</p>
<p>For more information on the various transactions you can submit, consult the <a href="transactions.html">Transaction Format</a>.</p>
<h1 id="api-methods">API Methods</h1>
<p>API methods for the Websocket and JSON-RPC APIs are defined by command names, and are divided into Public Commands and Admin Commands. Public Commands are not necessarily meant for the general public, but they are used by any client attached to the server. (Think of Public Commands as being for members or customers of the organization running the server, while the Admin Commands are for the personnel in charge of keeping the server operational.) Public Commands include the general operations for Ripple use, including checking the state of the ledger, finding a path to connecting users, and submitting a transaction, among others. Admin Commands, on the other hand, are meant only for the operators of the server, and include commands for managing the state of the server, the nodes it uses for validation, and other administrative features.</p>
<h2 id="list-of-public-commands">List of Public Commands</h2>
<ul>
<li><a href="#account-currencies"><code>account_currencies</code> - Get a list of currencies an account can send or receive</a></li>
<li><a href="#account-info"><code>account_info</code> - Get basic data about an account</a></li>
<li><a href="#account-lines"><code>account_lines</code> - Get info about an account's trust lines</a></li>
<li><a href="#account-objects"><code>account_objects</code> - Get all ledger objects owned by an account</a></li>
<li><a href="#account-offers"><code>account_offers</code> - Get info about an account's currency exchange offers</a></li>
<li><a href="#account-tx"><code>account_tx</code> - Get info about an account's transactions</a></li>
<li><a href="#book-offers"><code>book_offers</code> - Get info about offers to exchange two currencies</a></li>
<li><a href="#gateway-balances"><code>gateway_balances</code> - Calculate total amounts issued by an account</a></li>
<li><a href="#ledger"><code>ledger</code> - Get info about a ledger version</a></li>
<li><a href="#ledger-closed"><code>ledger_closed</code> - Get the latest closed ledger version</a></li>
<li><a href="#ledger-current"><code>ledger_current</code> - Get the current working ledger version</a></li>
<li><a href="#ledger-data"><code>ledger_data</code> - Get the raw contents of a ledger version</a></li>
<li><a href="#ledger-entry"><code>ledger_entry</code> - Get one element from a ledger version</a></li>
<li><a href="#noripple-check"><code>noripple_check</code> - Get recommended changes to an account's DefaultRipple and NoRipple settings</a></li>
<li><a href="#path-find"><code>path_find</code> - Find a path for a payment between two accounts and receive updates</a></li>
<li><a href="#ping"><code>ping</code> - Confirm connectivity with the server</a></li>
<li><a href="#random"><code>random</code> - Generate a random number</a></li>
<li><a href="#ripple-path-find"><code>ripple_path_find</code> - Find a path for payment between two accounts, once</a></li>
<li><a href="#server-info"><code>server_info</code> - Retrieve status of the server in human-readable format</a></li>
<li><a href="#server-state"><code>server_state</code> - Retrieve status of the server in machine-readable format</a></li>
<li><a href="#sign"><code>sign</code> - Cryptographically sign a transaction</a></li>
<li><a href="#submit"><code>submit</code> - Send a transaction to the network</a></li>
<li><a href="#subscribe"><code>subscribe</code> - Listen for updates about a particular subject</a></li>
<li><a href="#transaction-entry"><code>transaction_entry</code> - Retrieve info about a transaction from a particular ledger version</a></li>
<li><a href="#tx"><code>tx</code> - Retrieve info about a transaction from all the ledgers on hand</a></li>
<li><a href="#tx-history"><code>tx_history</code> - Retrieve info about all recent transactions</a></li>
<li><a href="#unsubscribe"><code>unsubscribe</code> - Stop listening for updates about a particular subject</a></li>
</ul>
<p>The <code>owner_info</code> command is deprecated. Use <a href="#account-objects"><code>account_objects</code></a> instead.</p>
<h2 id="list-of-admin-commands">List of Admin Commands</h2>
<ul>
<li><a href="#can-delete"><code>can_delete</code> - Allow online deletion of ledgers up to a specific ledger</a></li>
<li><a href="#connect"><code>connect</code> - Force the rippled server to connect to a specific peer</a></li>
<li><a href="#consensus-info"><code>consensus_info</code> - Get information about the state of consensus as it happens</a></li>
<li><a href="#fetch-info"><code>fetch_info</code> - Get information about the server's sync with the network</a></li>
<li><a href="#get-counts"><code>get_counts</code> - Get statistics about the server's internals and memory usage</a></li>
<li><a href="#ledger-accept"><code>ledger_accept</code> - Close and advance the ledger in stand-alone mode</a></li>
<li><a href="#ledger-cleaner"><code>ledger_cleaner</code> - Configure the ledger cleaner service to check for corrupted data</a></li>
<li><a href="#ledger-request"><code>ledger_request</code> - Query a peer server for a specific ledger version</a></li>
<li><a href="#log-level"><code>log_level</code> - Get or modify log verbosity</a></li>
<li><a href="#logrotate"><code>logrotate</code> - Reopen the log file</a></li>
<li><a href="#peers"><code>peers</code> - Get information about the peer servers connected</a></li>
<li><a href="#print"><code>print</code> - Get information about internal subsystems</a></li>
<li><a href="#stop"><code>stop</code> - Shut down the rippled server</a></li>
<li><a href="#validation-create"><code>validation_create</code> - Generate keys for a new rippled validator</a></li>
<li><a href="#validation-seed"><code>validation_seed</code> - Temporarily set key to be used for validating</a></li>
<li><a href="#wallet-propose"><code>wallet_propose</code> - Generate keys for a new account</a></li>
</ul>
<p>The following admin commands are deprecated and may be removed without further notice: </p>
<ul>
<li><code>ledger_header</code> - Use the <a href="#ledger"><code>ledger</code> command</a> instead.</li>
<li><code>unl_add</code>, <code>unl_delete</code>, <code>unl_list</code>, <code>unl_load</code>, <code>unl_network</code>, <code>unl_reset</code>, <code>unl_score</code> - Use the configuration file for UNL management instead.</li>
<li><code>wallet_seed</code> - Use <a href="#wallet-propose"><code>wallet_propose</code></a> instead.</li>
</ul>
<h2 id="commandline-access">Commandline Access</h2>
<p>The <code>rippled</code> application, in addition to acting as a server, can be run (as a separate instance) to act as a JSON-RPC client. In this mode, it has syntax for triggering most API methods with a single line from the command prompt, as described in each method. However, some methods don't have a commandline shortcut, so it also provides the following catch-all method for performing commands:</p>
<ul>
<li><a href="#json"><code>json</code> - Pass JSON through the commandline</a></li>
</ul>
<h1 id="account-information">Account Information</h1>
<p>Accounts are the core unit of authentication in the Ripple Network. Each account can hold balances in multiple currencies, and all transactions must be signed by an account's secret key. In order for an account to exist in a validated ledger version, it must hold a minimum reserve amount of XRP. (The <a href="reserves.html">reserve for an account</a> increases with the amount of data it is responsible for in the shared ledger.) It is expected that accounts will correspond loosely to individual users. </p>
<h2 id="account-currencies">account_currencies</h2>
<p><a href="https://github.com/ripple/rippled/blob/df966a9ac6dd986585ecccb206aff24452e41a30/src/ripple/rpc/handlers/AccountCurrencies.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>account_currencies</code> command retrieves a simple list of currencies that an account can send or receive, based on its trust lines. (This is not a thoroughly confirmed list, but it can be used to populate user interfaces.)</p>
<h4 id="request-format">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:13


*JSON-RPC*


wzxhzdk:14


</div>
<p><a class="button" href="ripple-api-tool.html#account_currencies">Try it! &gt;</a></p>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>String</td>
<td>A unique identifier for the account, most commonly the account's address.</td>
</tr>
<tr>
<td>strict</td>
<td>Boolean</td>
<td>(Optional) If true, only accept an address or public key for the account parameter. Defaults to false.</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(Optional) A 20-byte hex string for the ledger version to use. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>ledger_index</td>
<td>String or Unsigned Integer</td>
<td>(Optional) The sequence number of the ledger to use, or a shortcut string to choose a ledger automatically. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
</tbody>
</table>
<p>The following field is deprecated and should not be provided: <code>account_index</code>.</p>
<h4 id="response-format">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:15


*JSON-RPC*


wzxhzdk:16


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(May be omitted) The identifying hash of the ledger version used to retrieve this data, as hex.</td>
</tr>
<tr>
<td>ledger_index</td>
<td>Integer</td>
<td>The sequence number of the ledger version used to retrieve this data.</td>
</tr>
<tr>
<td>receive_currencies</td>
<td>Array of Strings</td>
<td>Array of currency codes for currencies that this account can receive. Each currency is either a 3-letter <a href="http://www.xe.com/iso4217.php">ISO 4217 Currency Code</a> or a 160-bit hex value according to the <a href="https://wiki.ripple.com/Currency_format">currency format</a>.</td>
</tr>
<tr>
<td>send_currencies</td>
<td>Array of Strings</td>
<td>Array of currency codes for currencies that this account can send. Each currency is either a 3-letter <a href="http://www.xe.com/iso4217.php">ISO 4217 Currency Code</a> or a 160-bit hex value according to the <a href="https://wiki.ripple.com/Currency_format">currency format</a>.</td>
</tr>
<tr>
<td>validated</td>
<td>Boolean</td>
<td>If <code>true</code>, this data comes from a validated ledger.</td>
</tr>
</tbody>
</table>
<p><em>Note:</em> The currencies that an account can send or receive are defined based on a simple check of its trust lines. If an account has a trust line for a currency and enough room to increase its balance, it can receive that currency. If the trust line's balance can go down, the account can send that currency. This method <em>does not</em> check whether the trust line is frozen or authorized.</p>
<h4 id="possible-errors">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>actNotFound</code> - The address specified in the <code>account</code> field of the request does not correspond to an account in the ledger.</li>
<li><code>lgrNotFound</code> - The ledger specified by the <code>ledger_hash</code> or <code>ledger_index</code> does not exist, or it does exist but the server does not have it.</li>
</ul>
<h2 id="account-info">account_info</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/AccountInfo.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>account_info</code> command retrieves information about an account, its activity, and its XRP balance. All information retrieved is relative to a particular version of the ledger. </p>
<h4 id="request-format-1">Request Format</h4>
<p>An example of an account_info request:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:17


*JSON-RPC*

wzxhzdk:18


*Commandline*

wzxhzdk:19


</div>
<p><a class="button" href="ripple-api-tool.html#account_info">Try it! &gt;</a></p>
<p>The request contains the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>String</td>
<td>A unique identifier for the account, most commonly the account's address.</td>
</tr>
<tr>
<td>strict</td>
<td>Boolean</td>
<td>(Optional, defaults to False) If set to True, then the <code>account</code> field will only accept a public key or account address.</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(Optional) A 20-byte hex string for the ledger version to use. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>ledger_index</td>
<td>String or Unsigned Integer</td>
<td>(Optional) The sequence number of the ledger to use, or a shortcut string to choose a ledger automatically. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
</tbody>
</table>
<p>The following fields are deprecated and should not be provided: <code>ident</code>, <code>account_index</code>, <code>ledger</code>.</p>
<h4 id="response-format-1">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:20


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with the result containing the requested account, its data, and a ledger to which it applies, as the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account_data</td>
<td>Object</td>
<td>Information about the requested account</td>
</tr>
<tr>
<td>account_data.Account</td>
<td>String</td>
<td>Address of the requested account</td>
</tr>
<tr>
<td>account_data.Balance</td>
<td>String</td>
<td>XRP balance in "drops" represented as a string</td>
</tr>
<tr>
<td>account_data.Flags</td>
<td>32-bit unsigned integer</td>
<td>Integer with different bits representing the status of several <a href="transactions.html#accountset-flags">account flags</a></td>
</tr>
<tr>
<td>account_data.LedgerEntryType</td>
<td>String</td>
<td>"AccountRoot" is the type of ledger entry that holds an account's data</td>
</tr>
<tr>
<td>account_data.OwnerCount</td>
<td>Integer</td>
<td>Number of other ledger entries (specifically, trust lines and offers) attributed to this account. This is used to calculate the total reserve required to use the account.</td>
</tr>
<tr>
<td>account_data.PreviousTxnID</td>
<td>String</td>
<td>Hash value representing the most recent transaction that affected this account node directly. <strong>Note:</strong> This does not include all changes to the account's trust lines and offers. Use <a href="#account-tx">account_tx</a> to get a more inclusive list.</td>
</tr>
<tr>
<td>account_data.Sequence</td>
<td>Integer</td>
<td>The sequence number of the next valid transaction for this account. (Each account starts with Sequence = 1 and increases each time a transaction is made.)</td>
</tr>
<tr>
<td>account_data.index</td>
<td>String</td>
<td>A unique index for the AccountRoot node that represents this account in the ledger.</td>
</tr>
<tr>
<td>ledger_current_index</td>
<td>Integer</td>
<td>(Omitted if <code>ledger_index</code> is provided instead) The sequence number of the most-current ledger, which was used when retrieving this information. The information does not contain any changes from ledgers newer than this one.</td>
</tr>
<tr>
<td>ledger_index</td>
<td>Integer</td>
<td>(Omitted if <code>ledger_current_index</code> is provided instead) The sequence number of the ledger used when retrieving this information. The information does not contain any changes from ledgers newer than this one.</td>
</tr>
<tr>
<td>validated</td>
<td>Boolean</td>
<td>True if this data is from a validated ledger version; if omitted or set to false, this data is not final. (<a href="https://ripplelabs.atlassian.net/browse/RIPD-275">New in version 0.26</a>)</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-1">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>actNotFound</code> - The address specified in the <code>account</code> field of the request does not correspond to an account in the ledger.</li>
<li><code>lgrNotFound</code> - The ledger specified by the <code>ledger_hash</code> or <code>ledger_index</code> does not exist, or it does exist but the server does not have it.</li>
</ul>
<h2 id="account-lines">account_lines</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/AccountLines.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>account_lines</code> method returns information about the account's lines of trust, including balances in all non-XRP currencies and assets. All information retrieved is relative to a particular version of the ledger.</p>
<h4 id="request-format-2">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:21


*JSON-RPC*


wzxhzdk:22


</div>
<p><a class="button" href="ripple-api-tool.html#account_lines">Try it! &gt;</a></p>
<p>The request accepts the following paramters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>String</td>
<td>A unique identifier for the account, most commonly the account's address as a base-58 string.</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(Optional) A 20-byte hex string for the ledger version to use. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>ledger_index</td>
<td>String or Unsigned Integer</td>
<td>(Optional) The sequence number of the ledger to use, or a shortcut string to choose a ledger automatically. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>peer</td>
<td>String</td>
<td>(Optional) A unique ID for a second account. If provided, show only lines of trust connecting the two accounts.</td>
</tr>
<tr>
<td>limit</td>
<td>Integer</td>
<td>(Optional, default varies) Limit the number of transactions to retrieve. The server is not required to honor this value. Cannot be smaller than 10 or larger than 400. (<a href="https://ripplelabs.atlassian.net/browse/RIPD-343">New in 0.26.4</a>)</td>
</tr>
<tr>
<td>marker</td>
<td><a href="#markers-and-pagination">(Not Specified)</a></td>
<td>(Optional) Server-provided value to specify where to resume retrieving data from. (<a href="https://ripplelabs.atlassian.net/browse/RIPD-343">New in 0.26.4</a>)</td>
</tr>
</tbody>
</table>
<p>The following parameters are deprecated and may be removed without further notice: <code>ledger</code> and <code>peer_index</code>.</p>
<h4 id="response-format-2">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:23


*JSON-RPC*


wzxhzdk:24


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the address of the account and an array of trust-line objects. Specifically, the result object contains the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>String</td>
<td>Unique address of the account this request corresponds to</td>
</tr>
<tr>
<td>lines</td>
<td>Array</td>
<td>Array of trust-line objects, as described below. If the number of trust-lines is large, only returns up to the <code>limit</code> at a time.</td>
</tr>
<tr>
<td>ledger_current_index</td>
<td>Integer</td>
<td>(Omitted if <code>ledger_hash</code> or <code>ledger_index</code> provided) Sequence number of the ledger version used when retrieving this data. (<a href="https://ripplelabs.atlassian.net/browse/RIPD-682">New in 0.26.4-sp1</a>)</td>
</tr>
<tr>
<td>ledger_index</td>
<td>Integer</td>
<td>(Omitted if <code>ledger_current_index</code> provided instead) Sequence number, provided in the request, of the ledger version that was used when retrieving this data. (<a href="https://ripplelabs.atlassian.net/browse/RIPD-682">New in 0.26.4-sp1</a>)</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(May be omitted) Hex hash, provided in the request, of the ledger version that was used when retrieving this data. (<a href="https://ripplelabs.atlassian.net/browse/RIPD-682">New in 0.26.4-sp1</a>)</td>
</tr>
<tr>
<td>marker</td>
<td><a href="#markers-and-pagination">(Not Specified)</a></td>
<td>Server-defined value. Pass this to the next call in order to resume where this call left off. Omitted when there are no additional pages after this one. (<a href="https://ripplelabs.atlassian.net/browse/RIPD-343">New in 0.26.4</a>)</td>
</tr>
</tbody>
</table>
<p>Each trust-line object has some combination of the following fields, although not necessarily all of them:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>String</td>
<td>The unique address of the account this line applies to.</td>
</tr>
<tr>
<td>balance</td>
<td>String</td>
<td>Representation of the numeric balance currently held against this line. A positive balance means that the account holds value; a negative balance means that the account owes value.</td>
</tr>
<tr>
<td>currency</td>
<td>String</td>
<td>The currency this line applies to</td>
</tr>
<tr>
<td>limit</td>
<td>String</td>
<td>The maximum amount of the given currency that the account is willing to owe the peer account</td>
</tr>
<tr>
<td>limit_peer</td>
<td>String</td>
<td>The maximum amount of currency that the peer account is willing to owe the account</td>
</tr>
<tr>
<td>no_ripple</td>
<td>Boolean</td>
<td>Whether or not the account has the <a href="https://ripple.com/knowledge_center/understanding-the-noripple-flag/">NoRipple flag</a> set for this line</td>
</tr>
<tr>
<td>no_ripple_peer</td>
<td>Boolean</td>
<td>Whether or not the peer account has the <a href="https://ripple.com/knowledge_center/understanding-the-noripple-flag/">NoRipple flag</a> set for the other direction of this trust line</td>
</tr>
<tr>
<td>quality_in</td>
<td>Unsigned Integer</td>
<td>Rate at which the account values incoming balances on this trust line, as a ratio of this value per 1 billion units. (For example, a value of 500 million represents a 0.5:1 ratio.) As a special case, 0 is treated as a 1:1 ratio.</td>
</tr>
<tr>
<td>quality_out</td>
<td>Unsigned Integer</td>
<td>Rate at which the account values outgoing balances on this trust line, as a ratio of this value per 1 billion units. (For example, a value of 500 million represents a 0.5:1 ratio.) As a special case, 0 is treated as a 1:1 ratio.</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-2">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>actNotFound</code> - The address specified in the <code>account</code> field of the request does not correspond to an account in the ledger.</li>
<li><code>lgrNotFound</code> - The ledger specified by the <code>ledger_hash</code> or <code>ledger_index</code> does not exist, or it does exist but the server does not have it.</li>
<li><code>actMalformed</code> - If the <code>marker</code> field provided is not acceptable. (See <a href="https://ripplelabs.atlassian.net/browse/RIPD-684">RIPD-684</a>)</li>
</ul>
<h2 id="account-offers">account_offers</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/AccountOffers.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>account_offers</code> method retrieves a list of offers made by a given account that are outstanding as of a particular ledger version.</p>
<h4 id="request-format-3">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:25


*JSON-RPC*


wzxhzdk:26


*Commandline*


wzxhzdk:27


</div>
<p><a class="button" href="ripple-api-tool.html#account_offers">Try it! &gt;</a></p>
<p>A request can include the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>String</td>
<td>A unique identifier for the account, most commonly the account's address as a base-58 string.</td>
</tr>
<tr>
<td>ledger</td>
<td>Unsigned integer, or String</td>
<td>(Deprecated, Optional) A unique identifier for the ledger version to use, such as a ledger sequence number, a hash, or a shortcut such as "validated".</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(Optional) A 20-byte hex string identifying the ledger version to use.</td>
</tr>
<tr>
<td>ledger_index</td>
<td>(Optional) Unsigned integer, or String</td>
<td>(Optional, defaults to <code>current</code>) The sequence number of the ledger to use, or "current", "closed", or "validated" to select a ledger dynamically. (See Ledger Indexes.)</td>
</tr>
<tr>
<td>limit</td>
<td>Integer</td>
<td>(Optional, default varies) Limit the number of transactions to retrieve. The server is not required to honor this value. Cannot be lower than 10 or higher than 400. (<a href="https://ripplelabs.atlassian.net/browse/RIPD-344">New in 0.26.4</a>)</td>
</tr>
<tr>
<td>marker</td>
<td><a href="#markers-and-pagination">(Not Specified)</a></td>
<td>Server-provided value to specify where to resume retrieving data from. (<a href="https://ripplelabs.atlassian.net/browse/RIPD-344">New in 0.26.4</a>)</td>
</tr>
</tbody>
</table>
<p>The following parameter is deprecated and may be removed without further notice: <code>ledger</code>.</p>
<h4 id="response-format-3">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:28


*JSON-RPC*


wzxhzdk:29


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>String</td>
<td>Unique address identifying the account that made the offers</td>
</tr>
<tr>
<td>offers</td>
<td>Array</td>
<td>Array of objects, where each object represents an offer made by this account that is outstanding as of the requested ledger version. If the number of offers is large, only returns up to <code>limit</code> at a time.</td>
</tr>
<tr>
<td>ledger_current_index</td>
<td>Integer</td>
<td>(Omitted if <code>ledger_hash</code> or <code>ledger_index</code> provided) Sequence number of the ledger version used when retrieving this data. (<a href="https://ripplelabs.atlassian.net/browse/RIPD-682">New in 0.26.4-sp1</a>)</td>
</tr>
<tr>
<td>ledger_index</td>
<td>Integer</td>
<td>(Omitted if <code>ledger_current_index</code> provided instead) Sequence number, provided in the request, of the ledger version that was used when retrieving this data. (<a href="https://ripplelabs.atlassian.net/browse/RIPD-682">New in 0.26.4-sp1</a>)</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(May be omitted) Hex hash, provided in the request, of the ledger version that was used when retrieving this data. (<a href="https://ripplelabs.atlassian.net/browse/RIPD-682">New in 0.26.4-sp1</a>)</td>
</tr>
<tr>
<td>marker</td>
<td><a href="#markers-and-pagination">(Not Specified)</a></td>
<td>Server-defined value. Pass this to the next call in order to resume where this call left off. Omitted when there are no pages of information after this one. (<a href="https://ripplelabs.atlassian.net/browse/RIPD-344">New in 0.26.4</a>)</td>
</tr>
</tbody>
</table>
<p>Each offer object contains the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>flags</td>
<td>Unsigned integer</td>
<td>Options set for this offer entry as bit-flags.</td>
</tr>
<tr>
<td>seq</td>
<td>Unsigned integer</td>
<td>Sequence number of the transaction that created this entry. (Transaction sequence numbers are relative to accounts.)</td>
</tr>
<tr>
<td>taker_gets</td>
<td>String or Object</td>
<td>The amount the account accepting the offer receives, as a String representing an amount in XRP, or a currency specification object. (See <a href="#specifying-currency-amounts">Specifying Currency Amounts</a>)</td>
</tr>
<tr>
<td>taker_pays</td>
<td>String or Object</td>
<td>The amount the account accepting the offer provides, as a String representing an amount in XRP, or a currency specification object. (See <a href="#specifying-currency-amounts">Specifying Currency Amounts</a>)</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-3">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>actNotFound</code> - The address specified in the <code>account</code> field of the request does not correspond to an account in the ledger.</li>
<li><code>lgrNotFound</code> - The ledger specified by the <code>ledger_hash</code> or <code>ledger_index</code> does not exist, or it does exist but the server does not have it.</li>
<li><code>actMalformed</code> - If the <code>marker</code> field provided is not acceptable. (See <a href="https://ripplelabs.atlassian.net/browse/RIPD-684">RIPD-684</a>)</li>
</ul>
<h2 id="account-objects">account_objects</h2>
<p><a href="https://github.com/ripple/rippled/blob/399c43cae6e90a428e9ce6a988123972b0f03c99/src/ripple/rpc/handlers/AccountObjects.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>account_objects</code> command returns the raw <a href="ripple-ledger.html">ledger format</a> for all objects owned by an account, such as <a href="transactions.html#lifecycle-of-an-offer">outstanding offers</a>, trust lines in non-default state, and tickets (which are part of forthcoming multi-sign code). For getting the balance of an account's trust lines, we recommend <a href="#account-lines"><code>account_lines</code></a> instead.</p>
<h4 id="request-format-4">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:30


*JSON-RPC*


wzxhzdk:31



*Commandline*


wzxhzdk:32


</div>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>String</td>
<td>A unique identifier for the account, most commonly the account's address.</td>
</tr>
<tr>
<td>type</td>
<td>String</td>
<td>(Optional) If included, filter results to include only this type of ledger node. Valid types include <code>state</code> (trust lines), <code>offer</code> (offers), and <code>ticket</code> (part of the forthcoming signing process).</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(Optional) A 20-byte hex string for the ledger version to use. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>ledger_index</td>
<td>String or Unsigned Integer</td>
<td>(Optional) The sequence number of the ledger to use, or a shortcut string to choose a ledger automatically. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>limit</td>
<td>Unsigned Integer</td>
<td>(Optional) The maximum number of objects to include in the results. Cannot be less than 10 or higher than 400 on non-admin connections. Defaults to 200.</td>
</tr>
<tr>
<td>marker</td>
<td><a href="#markers-and-pagination">(Not Specified)</a></td>
<td>(Optional) Server-provided value to specify where to resume retrieving data from.</td>
</tr>
</tbody>
</table>
<h4 id="response-format-4">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:33


*JSON-RPC*


wzxhzdk:34


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>String</td>
<td>Unique address of the account this request corresponds to</td>
</tr>
<tr>
<td>account_objects</td>
<td>Array</td>
<td>Array of objects owned by this account. Each object is in its raw <a href="ripple-ledger.html">ledger format</a>.</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(May be omitted) The identifying hash of the ledger that was used to generate this response.</td>
</tr>
<tr>
<td>ledger_index</td>
<td>Number</td>
<td>(May be omitted) The sequence number of the ledger version that was used to generate this response.</td>
</tr>
<tr>
<td>ledger_current_index</td>
<td>Number</td>
<td>(May be omitted) The sequence number of the current in-progress ledger version that was used to generate this response.</td>
</tr>
<tr>
<td>limit</td>
<td>Number</td>
<td>(May be omitted) The limit that was used in this request, if any.</td>
</tr>
<tr>
<td>marker</td>
<td><a href="#markers-and-pagination">(Not Specified)</a></td>
<td>Server-defined value. Pass this to the next call in order to resume where this call left off. Omitted when there are no additional pages after this one.</td>
</tr>
<tr>
<td>validated</td>
<td>Boolean</td>
<td>If <code>true</code>, this information comes from ledger version that has been validated by consensus.</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-4">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>actNotFound</code> - The address specified in the <code>account</code> field of the request does not correspond to an account in the ledger.</li>
<li><code>lgrNotFound</code> - The ledger specified by the <code>ledger_hash</code> or <code>ledger_index</code> does not exist, or it does exist but the server does not have it.</li>
</ul>
<h2 id="account-tx">account_tx</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/AccountTx.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>account_tx</code> method retrieves a list of transactions that involved the specified account.</p>
<h4 id="request-format-5">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:35


*JSON-RPC*

wzxhzdk:36


*Commandline*

wzxhzdk:37


</div>
<p><a class="button" href="ripple-api-tool.html#account_tx">Try it! &gt;</a></p>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>String</td>
<td>A unique identifier for the account, most commonly the account's address.</td>
</tr>
<tr>
<td>ledger_index_min</td>
<td>Integer</td>
<td>Use to specify the earliest ledger to include transactions from. A value of <code>-1</code> instructs the server to use the earliest validated ledger version available.</td>
</tr>
<tr>
<td>ledger_index_max</td>
<td>Integer</td>
<td>Use to specify the most recent ledger to include transactions from. A value of <code>-1</code> instructs the server to use the most recent validated ledger version available.</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(Optional) Use instead of ledger_index_min and ledger_index_max to look for transactions from a single ledger only. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>ledger_index</td>
<td>String or Unsigned Integer</td>
<td>(Optional) Use instead of ledger_index_min and ledger_index_max to look for transactions from a single ledger only. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>binary</td>
<td>Boolean</td>
<td>(Optional, defaults to False) If set to True, return transactions as hex strings instead of JSON.</td>
</tr>
<tr>
<td>forward</td>
<td>boolean</td>
<td>(Optional, defaults to False) If set to True, return values indexed with the oldest ledger first. Otherwise, the results are indexed with the newest ledger first. (Each page of results may not be internally ordered, but the pages are overall ordered.)</td>
</tr>
<tr>
<td>limit</td>
<td>Integer</td>
<td>(Optional, default varies) Limit the number of transactions to retrieve. The server is not required to honor this value.</td>
</tr>
<tr>
<td>marker</td>
<td><a href="#markers-and-pagination">(Not Specified)</a></td>
<td>Server-provided value to specify where to resume retrieving data from. This value is stable even if there is a change in the server's range of available ledgers.</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/AccountTxSwitch.cpp" title="Source">[Source]<br/></a>
There is also a deprecated legacy variation of the <code>account_tx</code> method. For that reason, we recommend <em>not using any of the following fields</em>: <code>offset</code>, <code>count</code>, <code>descending</code>, <code>ledger_max</code>, <code>ledger_min</code>.</p>
<h5 id="iterating-over-queried-data"><strong>Iterating over queried data</strong></h5>
<p>As with other paginated methods, you can use the <code>marker</code> field to return multiple pages of data.</p>
<p>In the time between requests, <code>"ledger_index_min": -1</code> and <code>"ledger_index_max": -1</code> may change to refer to different ledger versions than they did before. The <code>marker</code> field can safely paginate even if there are changes in the ledger range from the request, so long as the marker does not indicate a point outside the range of ledgers specified in the request.</p>
<h4 id="response-format-5">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:38


*JSON-RPC*

wzxhzdk:39


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>String</td>
<td>Unique address identifying the related account</td>
</tr>
<tr>
<td>ledger_index_min</td>
<td>Integer</td>
<td>The sequence number of the earliest ledger actually searched for transactions.</td>
</tr>
<tr>
<td>ledger_index_max</td>
<td>Integer</td>
<td>The sequence number of the most recent ledger actually searched for transactions.</td>
</tr>
<tr>
<td>limit</td>
<td>Integer</td>
<td>The <code>limit</code> value used in the request. (This may differ from the actual limit value enforced by the server.)</td>
</tr>
<tr>
<td>marker</td>
<td><a href="#markers-and-pagination">(Not Specified)</a></td>
<td>Server-defined value. Pass this to the next call in order to resume where this call left off.</td>
</tr>
<tr>
<td>offset</td>
<td>Integer</td>
<td>The <code>offset</code> value used in the request.</td>
</tr>
<tr>
<td>transactions</td>
<td>Array</td>
<td>Array of transactions matching the request's criteria, as explained below.</td>
</tr>
<tr>
<td>validated</td>
<td>Boolean</td>
<td>If included and set to <code>true</code>, the information in this request comes from a validated ledger version. Otherwise, the information is subject to change.</td>
</tr>
</tbody>
</table>
<p><strong><em>Note:</em></strong> The server may respond with different values of <code>ledger_index_min</code> and <code>ledger_index_max</code> than you provided in the request, for example if it did not have the versions you specified on hand.</p>
<p>Each transaction object includes the following fields, depending on whether it was requested in JSON or hex string (<code>"binary":true</code>) format.</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ledger_index</td>
<td>Integer</td>
<td>The sequence number of the ledger version that included this transaction.</td>
</tr>
<tr>
<td>meta</td>
<td>Object (JSON) or String (Binary)</td>
<td>If <code>binary</code> is True, then this is a hex string of the transaction metadata. Otherwise, the transaction metadata is included in JSON format.</td>
</tr>
<tr>
<td>tx</td>
<td>Object</td>
<td>(JSON mode only) JSON object defining the transaction</td>
</tr>
<tr>
<td>tx_blob</td>
<td>String</td>
<td>(Binary mode only) Unique hashed String representing the transaction.</td>
</tr>
<tr>
<td>validated</td>
<td>Boolean</td>
<td>Whether or not the transaction is included in a validated ledger. Any transaction not yet in a validated ledger is subject to change.</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-5">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>actMalformed</code> - If the address specified in the <code>account</code> field of the request is not formatted properly.</li>
<li><code>actBitcoin</code> - If the address specified in the <code>account</code> field is formatted like a Bitcoin address instead of a Ripple address.</li>
<li><code>lgrIdxsInvalid</code> - If the ledger specified by the <code>ledger_index_min</code> or <code>ledger_index_max</code> does not exist, or if it does exist but the server does not have it.</li>
</ul>
<h2 id="noripple-check">noripple_check</h2>
<p><a href="https://github.com/ripple/rippled/blob/9111ad1a9dc37d49d085aa317712625e635197c0/src/ripple/rpc/handlers/NoRippleCheck.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>noripple_check</code> command provides a quick way to check the status of <a href="https://ripple.com/knowledge_center/understanding-the-noripple-flag/">the DefaultRipple field for an account and the NoRipple flag of its trust lines</a>, compared with the recommended settings.</p>
<h4 id="request-format-6">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:40


*JSON-RPC*


wzxhzdk:41


</div>
<p><strong>Note:</strong> There is no command-line syntax for this method. Use the <a href="#json"><code>json</code> command</a> to access this from the command line.</p>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>String</td>
<td>A unique identifier for the account, most commonly the account's address.</td>
</tr>
<tr>
<td>role</td>
<td>String</td>
<td>Whether the account refers to a <code>gateway</code> or <code>user</code>. Recommendations depend on the role of the account. Gateways must have DefaultRipple enabled and must disable NoRipple on all trust lines. Users should have DefaultRipple disabled, and should enable NoRipple on all trust lines.</td>
</tr>
<tr>
<td>transactions</td>
<td>Boolean</td>
<td>(Optional) If <code>true</code>, include an array of suggested <a href="transactions.html">transactions</a>, as JSON objects, that you can sign and submit to fix the problems. Defaults to false.</td>
</tr>
<tr>
<td>limit</td>
<td>Unsigned Integer</td>
<td>(Optional) The maximum number of trust line problems to include in the results. Defaults to 300.</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(Optional) A 20-byte hex string for the ledger version to use. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>ledger_index</td>
<td>String or Unsigned Integer</td>
<td>(Optional) The sequence number of the ledger to use, or a shortcut string to choose a ledger automatically. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
</tbody>
</table>
<h4 id="response-format-6">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:42


*JSON-RPC*


wzxhzdk:43


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ledger_current_index</td>
<td>Number</td>
<td>The sequence number of the ledger used to calculate these results.</td>
</tr>
<tr>
<td>problems</td>
<td>Array</td>
<td>Array of strings with human-readable descriptions of the problems. This includes up to one entry if the account's DefaultRipple setting is not as recommended, plus up to <code>limit</code> entries for trust lines whose NoRipple setting is not as recommended.</td>
</tr>
<tr>
<td>transactions</td>
<td>Array</td>
<td>(May be omitted) If the request specified <code>transactions</code> as <code>true</code>, this is an array of JSON objects, each of which is the JSON form of a <a href="transactions.html">transaction</a> that should fix one of the described problems. The length of this array is the same as the <code>problems</code> array, and each entry is intended to fix the problem described at the same index into that array.</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-6">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>actNotFound</code> - The address specified in the <code>account</code> field of the request does not correspond to an account in the ledger.</li>
<li><code>lgrNotFound</code> - The ledger specified by the <code>ledger_hash</code> or <code>ledger_index</code> does not exist, or it does exist but the server does not have it.</li>
</ul>
<h2 id="gateway-balances">gateway_balances</h2>
<p><a href="https://github.com/ripple/rippled/blob/9111ad1a9dc37d49d085aa317712625e635197c0/src/ripple/rpc/handlers/GatewayBalances.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>gateway_balances</code> command calculates the total balances issued by a given account, optionally excluding amounts held by specific "hot wallet" addresses. <em>(New in <a href="https://github.com/ripple/rippled/releases/tag/0.28.2">version 0.28.2</a>.)</em></p>
<h4 id="request-format-7">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:44


*JSON-RPC*


wzxhzdk:45


</div>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>String</td>
<td>The address of the account to use</td>
</tr>
<tr>
<td>strict</td>
<td>Boolean</td>
<td>(Optional) If true, only accept an address or public key for the account parameter. Defaults to false.</td>
</tr>
<tr>
<td>hotwallet</td>
<td>String or Array</td>
<td>The address of a hot wallet account to exclude from the balances issued, or an array of such addresses.</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(Optional) A 20-byte hex string for the ledger version to use. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>ledger_index</td>
<td>String or Unsigned Integer</td>
<td>(Optional) The sequence number of the ledger version to use, or a shortcut string to choose a ledger automatically. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
</tbody>
</table>
<h4 id="response-format-7">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:46


*JSON-RPC*


wzxhzdk:47


</div>
<p><strong>Note:</strong> There is no command-line syntax for this method. Use the <a href="#json"><code>json</code> command</a> to access this from the command line.</p>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>obligations</td>
<td>Object</td>
<td>(Omitted if empty) Total amounts issued to accounts that are not hot wallets, as a map of currencies to the total value issued.</td>
</tr>
<tr>
<td>balances</td>
<td>Object</td>
<td>(Omitted if empty) Amounts issued to the <code>hotwallet</code> accounts from the request. The keys are hot wallet addresses and the values are arrays of currency amounts they hold. The issuer (omitted from the currency amounts) is the account from the request.</td>
</tr>
<tr>
<td>assets</td>
<td>Object</td>
<td>(Omitted if empty) Total amounts held that are issued by others. For the recommended gateway configuration, there should be none.</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(May be omitted) The identifying hash of the ledger that was used to generate this response.</td>
</tr>
<tr>
<td>ledger_index</td>
<td>Number</td>
<td>(May be omitted) The sequence number of the ledger version that was used to generate this response.</td>
</tr>
<tr>
<td>ledger_current_index</td>
<td>Number</td>
<td>(May be omitted) The sequence number of the current in-progress ledger version that was used to generate this response.</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-7">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>invalidHotWallet</code> - One or more of the addresses specified in the <code>hotwallet</code> field is not the address of an account holding currency issued by the account from the request.</li>
<li><code>actNotFound</code> - The address specified in the <code>account</code> field of the request does not correspond to an account in the ledger.</li>
<li><code>lgrNotFound</code> - The ledger specified by the <code>ledger_hash</code> or <code>ledger_index</code> does not exist, or it does exist but the server does not have it.</li>
</ul>
<h2 id="wallet-propose">wallet_propose</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/WalletPropose.cpp" title="Source">[Source]<br/></a></p>
<p>Use the <code>wallet_propose</code> method to generate the keys needed for a new account. The account created this way will only become officially included in the Ripple network when it receives a transaction that provides enough XRP to meet the account reserve. (The <code>wallet_propose</code> command does not affect the global network. Technically, it is not strictly necessary for creating a new account: you could generate keys some other way, but that is not recommended.)</p>
<p><em>The <code>wallet_propose</code> request is an admin command that cannot be run by unpriviledged users!</em> (Since admin commands are not transmitted over the outside network this command is protected against people sniffing the network for account secrets.)</p>
<h4 id="request-format-8">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:48


*JSON-RPC*

wzxhzdk:49


*Commandline*

wzxhzdk:50


</div>
<p>The request can contain the following parameter:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>passphrase</td>
<td>String</td>
<td>(Optional) Specify a passphrase, for testing purposes. If omitted, the server will use a random number to generate the master key. Outside of testing purposes, keys should always be randomly generated. Some values, which resemble Ripple addresses and some other formats, are prohibited.</td>
</tr>
</tbody>
</table>
<h4 id="response-format-8">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:51


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing various important information about the new account, including the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>master_seed</td>
<td>String</td>
<td>The <a href="https://ripple.com/wiki/Master_Key">master seed</a> from which all other information about this account is derived, in Ripple's base-58 encoded string format.</td>
</tr>
<tr>
<td>master_seed_hex</td>
<td>String</td>
<td>The master seed, in hex format.</td>
</tr>
<tr>
<td>master_key</td>
<td>String</td>
<td>The master seed, in <a href="http://tools.ietf.org/html/rfc1751">RFC 1751</a> format.</td>
</tr>
<tr>
<td>account_id</td>
<td>String</td>
<td>The public address of the account.</td>
</tr>
<tr>
<td>public_key</td>
<td>String</td>
<td>The public key of the account, in encoded string format.</td>
</tr>
<tr>
<td>public_key_hex</td>
<td>String</td>
<td>The public key of the account, in hex format.</td>
</tr>
</tbody>
</table>
<p>The key generated by this method can also be used as a regular key for an account if you use the <a href="transactions.html#setregularkey">SetRegularKey transaction type</a> to do so.</p>
<h4 id="possible-errors-8">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>badSeed</code> - The <code>passphrase</code> field of the request has an invalid value, such as an empty string, or a format resembling a Ripple address or Ripple secret.</li>
</ul>
<h1 id="ledger-information">Ledger Information</h1>
<p>The globally-shared ledger is the core of the Ripple Network. Each <code>rippled</code> server keeps a current version of the ledger, which contains all the accounts, transactions, offers, and other data in the network in an optimized tree format. As transactions and offers are proposed, each server incorporates them into its current copy of the ledger, closes it periodically, and (if configured) participates in the process of advancing the globally-validated version. After concensus is reached in the network, that ledger version is validated and becomes permanently immutable. Any transactions that were not included in one ledger become candidates to be included in the next validated version.</p>
<h2 id="ledger">ledger</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/LedgerHandler.cpp" title="Source">[Source]<br/></a></p>
<p>Retrieve information about the public ledger.</p>
<h4 id="request-format-9">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:52


*JSON-RPC*

wzxhzdk:53


*Commandline*

wzxhzdk:54


</div>
<p><a class="button" href="ripple-api-tool.html#ledger">Try it! &gt;</a></p>
<p>The request can contain the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>accounts</td>
<td>Boolean</td>
<td>(Optional, defaults to false) If true, return information on accounts in the ledger. <em>Admin required.</em> If enabled, this method returns a large amount of data, which may cause the request to fail due to a timeout, depending on the server load and capabilities.</td>
</tr>
<tr>
<td>transactions</td>
<td>Boolean</td>
<td>(Optional, defaults to false) If true, return information on transactions in the specified ledger version.</td>
</tr>
<tr>
<td>full</td>
<td>Boolean</td>
<td>(Optional, defaults to false) If true, return full information on the entire ledger. (Equivalent to enabling <code>transactions</code>, <code>accounts</code>, and <code>expand</code> <em>Admin required</em></td>
</tr>
<tr>
<td>expand</td>
<td>Boolean</td>
<td>(Optional, defaults to false) Provide full JSON-formatted information for transaction/account information instead of just hashes</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(Optional) A 20-byte hex string for the ledger version to use. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>ledger_index</td>
<td>String or Unsigned Integer</td>
<td>(Optional) The sequence number of the ledger to use, or a shortcut string to choose a ledger automatically. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>binary</td>
<td>Boolean</td>
<td>(Optional, defaults to false) If <code>transactions</code> and <code>expand</code> are both true, and this option is also true, return transaction information in binary format instead of JSON format. <em>(New in <a href="https://github.com/ripple/rippled/releases/tag/0.28.0">rippled v0.28.0</a>)</em></td>
</tr>
</tbody>
</table>
<p>The <code>ledger</code> field is deprecated and may be removed without further notice.</p>
<h4 id="response-format-9">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:55


*JSON-RPC*

wzxhzdk:56


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing information about the ledger, including the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account_hash</td>
<td>String</td>
<td>Hash of all account state information in this ledger, as hex</td>
</tr>
<tr>
<td>close_time</td>
<td>Integer</td>
<td>The time this ledger was closed, in seconds since the <a href="#specifying-time">Ripple Epoch</a></td>
</tr>
<tr>
<td>close_time_human</td>
<td>String</td>
<td>The time this ledger was closed, in human-readable format</td>
</tr>
<tr>
<td>close_time_resolution</td>
<td>Integer</td>
<td>Approximate number of seconds between closing one ledger version and closing the next one</td>
</tr>
<tr>
<td>closed</td>
<td>Boolean</td>
<td>Whether or not this ledger has been closed</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>Unique identifying hash of the entire ledger.</td>
</tr>
<tr>
<td>ledger_index</td>
<td>String</td>
<td>Ledger sequence number as a quoted integer</td>
</tr>
<tr>
<td>parent_hash</td>
<td>String</td>
<td>Unique identifying hash of the ledger that came immediately before this one.</td>
</tr>
<tr>
<td>total_coins</td>
<td>String</td>
<td>Total number of XRP drops in the network, as a quoted integer. (This decreases as transaction costs destroy XRP.)</td>
</tr>
<tr>
<td>transaction_hash</td>
<td>String</td>
<td>Hash of the transaction information included in this ledger, as hex</td>
</tr>
</tbody>
</table>
<p>The following fields are deprecated and may be removed without further notice: <code>accepted</code>, <code>hash</code>, <code>seqNum</code>, <code>totalCoins</code>.</p>
<h4 id="possible-errors-9">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>lgrNotFound</code> - The ledger specified by the <code>ledger_hash</code> or <code>ledger_index</code> does not exist, or it does exist but the server does not have it.</li>
<li><code>noPermission</code> - If you specified <code>full</code> or <code>accounts</code> as true, but are not connected to the server as an admin (usually, admin requires connecting on a local port).</li>
</ul>
<h2 id="ledger-closed">ledger_closed</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/LedgerClosed.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>ledger_closed</code> method returns the unique identifiers of the most recently closed ledger. (This ledger is not necessarily validated and immutable yet.)</p>
<h4 id="request-format-10">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:57


*JSON-RPC*

wzxhzdk:58


*Commandline*

wzxhzdk:59


</div>
<p><a class="button" href="ripple-api-tool.html#ledger_closed">Try it! &gt;</a></p>
<p>This method accepts no parameters.</p>
<h4 id="response-format-10">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:60


*JSON-RPC*

wzxhzdk:61


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>20-byte hex string with a unique hash of the ledger</td>
</tr>
<tr>
<td>ledger_index</td>
<td>Unsigned Integer</td>
<td>Sequence number of this ledger</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-10">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
</ul>
<h2 id="ledger-current">ledger_current</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/LedgerCurrent.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>ledger_current</code> method returns the unique identifiers of the current in-progress ledger. This command is mostly useful for testing, because the ledger returned is still in flux.</p>
<h4 id="request-format-11">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:62


*JSON-RPC*

wzxhzdk:63


*Commandline*

wzxhzdk:64


</div>
<p><a class="button" href="ripple-api-tool.html#ledger_current">Try it! &gt;</a></p>
<p>The request contains no parameters.</p>
<h4 id="response-format-11">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:65


*JSON-RPC*

wzxhzdk:66


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following field:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ledger_current_index</td>
<td>Unsigned Integer</td>
<td>Sequence number of this ledger</td>
</tr>
</tbody>
</table>
<p>A <code>ledger_hash</code> field is not provided, because the hash of the current ledger is constantly changing along with its contents.</p>
<h4 id="possible-errors-11">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
</ul>
<h2 id="ledger-data">ledger_data</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/LedgerData.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>ledger_data</code> method retrieves contents of the specified ledger. You can iterate through several calls in order to retrieve the entire contents of a single ledger version.</p>
<h4 id="request-format-12">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:67


*JSON-RPC*

wzxhzdk:68


</div>
<p><strong><em>Note:</em></strong> There is no commandline syntax for <code>ledger_data</code>. You can use the <a href="#json"><code>json</code> command</a> to access this method from the commandline instead.</p>
<p>A request can include the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>(Arbitrary)</td>
<td>(WebSocket only) Any identifier to separate this request from others in case the responses are delayed or out of order.</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(Optional) A 20-byte hex string for the ledger version to use. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>ledger_index</td>
<td>String or Unsigned Integer</td>
<td>(Optional) The sequence number of the ledger to use, or a shortcut string to choose a ledger automatically. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>binary</td>
<td>Boolean</td>
<td>(Optional, defaults to False) If set to true, return data nodes as hashed hex strings instead of JSON.</td>
</tr>
<tr>
<td>limit</td>
<td>Integer</td>
<td>(Optional, default varies) Limit the number of nodes to retrieve. The server is not required to honor this value.</td>
</tr>
<tr>
<td>marker</td>
<td><a href="#markers-and-pagination">(Not Specified)</a></td>
<td>Server-provided value to specify where to resume retrieving data from.</td>
</tr>
</tbody>
</table>
<p>The <code>ledger</code> field is deprecated and may be removed without further notice.</p>
<h4 id="response-format-12">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket (binary:true)*

wzxhzdk:69


*WebSocket (binary:false)*

wzxhzdk:70


*JSON-RPC (binary:true)*

wzxhzdk:71


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ledger_index</td>
<td>Unsigned Integer</td>
<td>Sequence number of this ledger</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>Unique identifying hash of the entire ledger.</td>
</tr>
<tr>
<td>state</td>
<td>Array</td>
<td>Array of JSON objects containing data from the tree, as defined below</td>
</tr>
<tr>
<td>marker</td>
<td><a href="#markers-and-pagination">(Not Specified)</a></td>
<td>Server-defined value. Pass this to the next call in order to resume where this call left off.</td>
</tr>
</tbody>
</table>
<p>The format of each object in the <code>state</code> array depends on whether <code>binary</code> was set to true or not in the request. Each <code>state</code> object may include the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td>String</td>
<td>(Only included if <code>"binary":true</code>) Hex representation of the requested data</td>
</tr>
<tr>
<td>LedgerEntryType</td>
<td>String</td>
<td>(Only included if <code>"binary":false</code>) String indicating what type of ledger node this object represents. See <a href="ripple-ledger.html">ledger format</a> for the full list.</td>
</tr>
<tr>
<td>(Additional fields)</td>
<td>(Various)</td>
<td>(Only included if <code>"binary":false</code>) Additional fields describing this object, depending on which LedgerEntryType it is.</td>
</tr>
<tr>
<td>index</td>
<td>String</td>
<td>Unique identifier for this ledger entry, as hex.</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-12">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a></li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>lgrNotFound</code> - The ledger specified by the <code>ledger_hash</code> or <code>ledger_index</code> does not exist, or it does exist but the server does not have it.</li>
</ul>
<h2 id="ledger-entry">ledger_entry</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/LedgerEntry.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>ledger_entry</code> method returns a single ledger node from the Ripple Consensus Ledger. See <a href="ripple-ledger.html">ledger format</a> for information on the different types of objects you can retrieve.</p>
<p><strong><em>Note:</em></strong> There is no commandline version of this method. You can use the <a href="#json"><code>json</code> command</a> to access this method from the commandline instead.</p>
<h4 id="request-format-13">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:72


*JSON-RPC*

wzxhzdk:73


</div>
<p><a class="button" href="ripple-api-tool.html#ledger_entry">Try it! &gt;</a></p>
<p>This method can retrieve several different types of data. You can select which type of item to retrieve by passing the appropriate parameters. Specifically, you should provide exactly one of the following fields:</p>
<ol>
<li><code>index</code> - Retrieve an individual ledger node by its unique index</li>
<li><code>account_root</code> - Retrieve an account node, similar to the <a href="#account-info">account_info</a> command</li>
<li><code>directory</code> - Retrieve a directory node, which contains a list of IDs linking things</li>
<li><code>offer</code> - Retrieve an offer node, which defines an offer to exchange currency</li>
<li><code>ripple_state</code> - Retrieve a RippleState node, which is a trust line where non-XRP balances are held</li>
</ol>
<p>If you specify more than one of the above items, the server will retrieve only of them; it is undefined which one will be chosen.</p>
<p>The full list of parameters recognized by this method is as follows:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>String</td>
<td>(Optional) Specify the unique identifier of a single ledger entry to retrieve.</td>
</tr>
<tr>
<td>account_root</td>
<td>String</td>
<td>(Optional) Specify the unique address of an account object to retrieve.</td>
</tr>
<tr>
<td>directory</td>
<td>Object or String</td>
<td>(Optional) Specify a directory node to retrieve from the tree. (Directory nodes each contain a list of IDs for things contained in them.) If a string, interpret as the unique key to the directory, in hex. If an object, requires either <code>dir_root</code> or <code>owner</code> as a sub-field, plus optionally a <code>sub_index</code> sub-field.</td>
</tr>
<tr>
<td>directory.sub_index</td>
<td>Unsigned Integer</td>
<td>(Optional) If provided, jumps to a further sub-node in the directory linked-list.</td>
</tr>
<tr>
<td>directory.dir_root</td>
<td>String</td>
<td>(Required if <code>directory</code> is specified as an object and <code>directory.owner</code> is not provided) Unique index identifying the directory to retrieve, as a hex string.</td>
</tr>
<tr>
<td>directory.owner</td>
<td>String</td>
<td>(Required if <code>directory</code> is specified as an object and <code>directory.dir_root</code> is not provided) Unique address of the account associated with this directory</td>
</tr>
<tr>
<td>offer</td>
<td>Object or String</td>
<td>(Optional) Specify an offer to retrieve. If a string, interpret as a 256-key hex hash. If an object, requires the sub-fields <code>account</code> and <code>seq</code> to uniquely identify the offer.</td>
</tr>
<tr>
<td>offer.account</td>
<td>String</td>
<td>(Required if <code>offer</code> specified) The unique address of the account making the offer to retrieve.</td>
</tr>
<tr>
<td>offer.seq</td>
<td>Unsigned Integer</td>
<td>(Required if <code>offer</code> specified) The sequence number of the transaction making the offer to retrieve.</td>
</tr>
<tr>
<td>ripple_state</td>
<td>Object</td>
<td>(Optional) Object specifying the RippleState entry to retrieve. The <code>accounts</code> and <code>currency</code> sub-fields are required to uniquely specify the RippleState entry to retrieve.</td>
</tr>
<tr>
<td>ripple_state.accounts</td>
<td>Array</td>
<td>(Required if <code>ripple_state</code> specified) 2-length array of account address strings, defining the two accounts linked by this RippleState entry</td>
</tr>
<tr>
<td>ripple_state.currency</td>
<td>String</td>
<td>(Required if <code>ripple_state</code> specified) String representation of a currency that this RippleState entry relates to, as either a 3-letter currency code or a 40-character hex code</td>
</tr>
<tr>
<td>binary</td>
<td>Boolean</td>
<td>(Optional, defaults to false) If true, return hashed data as hex strings. Otherwise, return data in JSON format.</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(Optional) A 20-byte hex string for the ledger version to use. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>ledger_index</td>
<td>String or Unsigned Integer</td>
<td>(Optional) The sequence number of the ledger to use, or a shortcut string to choose a ledger automatically. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
</tbody>
</table>
<p>The <code>generator</code> and <code>ledger</code> parameters are deprecated and may be removed without further notice.</p>
<h4 id="response-format-13">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:74


*JSON-RPC*

wzxhzdk:75


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>String</td>
<td>Unique identifying key for this ledger_entry</td>
</tr>
<tr>
<td>ledger_index</td>
<td>Unsigned Integer</td>
<td>Unique sequence number of the ledger from which this data was retrieved</td>
</tr>
<tr>
<td>node</td>
<td>Object</td>
<td>(<code>"binary":false</code> only) Object containing the data of this ledger node, according to the <a href="ripple-ledger.html">ledger format</a>.</td>
</tr>
<tr>
<td>node_binary</td>
<td>String</td>
<td>(<code>"binary":true</code> only) Binary data of the ledger node retrieved, as hex.</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-13">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>lgrNotFound</code> - The ledger specified by the <code>ledger_hash</code> or <code>ledger_index</code> does not exist, or it does exist but the server does not have it.</li>
</ul>
<h2 id="ledger-request">ledger_request</h2>
<p><a href="https://github.com/ripple/rippled/blob/e980e69eca9ea843d200773eb1f43abe3848f1a0/src/ripple/rpc/handlers/LedgerRequest.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>ledger_request</code> command tells server to fetch a specific ledger version from its connected peers. This only works if one of the server's immediately-connected peers has that ledger. You may need to run the command several times to completely fetch a ledger.</p>
<p><em>The <code>ledger_request</code> request is an admin command that cannot be run by unpriviledged users!</em></p>
<h4 id="request-format-14">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:76


*Commandline*


wzxhzdk:77


</div>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ledger_index</td>
<td>Number</td>
<td>(Optional) Retrieve the specified ledger by its sequence number.</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(Optional) Retrieve the specified ledger by its identifying hash.</td>
</tr>
</tbody>
</table>
<p>You must provide either <code>ledger_index</code> or <code>ledger_hash</code> but not both.</p>
<h4 id="response-format-14">Response Format</h4>
<p>The response follows the <a href="#response-formatting">standard format</a>. However, the request returns a failure response if it does not have the specified ledger <em>even if it successfully instructed the <code>rippled</code> server to start retrieving the ledger</em>.</p>
<p><strong>Note:</strong> In order to retrieve a ledger, the rippled server must have a direct peer with that ledger in its history. If none of the peers have the requested ledger, you can use the <a href="#connect"><code>connect</code> command</a> or the <code>fixed_ips</code> section of the config file to add Ripple Labs' full-history server at <code>s2.ripple.com</code> and then make the <code>ledger_request</code> request again.</p>
<p>A failure response indicates the status of fetching the ledger. A successful response contains the information for the ledger in a similar format to the <a href="#ledger"><code>ledger</code> command</a>.</p>
<div class="multicode">

*Commandline (failure)*


wzxhzdk:78


*Commandline (success)*


wzxhzdk:79


</div>
<p>The fields of the "failure" response (the ledger was requested, but has not been fully retrieved yet) can include any of the following:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td>String</td>
<td>The hash of the requested ledger, if the server knows it.</td>
</tr>
<tr>
<td>have_header</td>
<td>Boolean</td>
<td>Whether the server has the header section of the requested ledger.</td>
</tr>
<tr>
<td>have_state</td>
<td>Boolean</td>
<td>(May be omitted) Whether the server has the state section of the requested ledger.</td>
</tr>
<tr>
<td>have_transactions</td>
<td>Boolean</td>
<td>(May be omitted) Whether the server has the transaction section of the requested ledger.</td>
</tr>
<tr>
<td>needed_state_hashes</td>
<td>Array of Strings</td>
<td>(May be omitted) Up to 16 hashes of nodes in the state tree that the server still needs to retrieve.</td>
</tr>
<tr>
<td>needed_transaction_hashes</td>
<td>Array of Strings</td>
<td>(May be omitted) Up to 16 hashes of nodes in the transaction tree that the server still needs to retrieve.</td>
</tr>
<tr>
<td>peers</td>
<td>Number</td>
<td>How many peers the server is querying in its attempt to find this ledger.</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-14">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing. This error can also occur if you specify a ledger index equal or higher than the current in-progress ledger.</li>
<li><code>ledgerNotFound</code> - If the ledger is not yet available. This indicates that the server has started fetching the ledger, although it may fail if none of its connected peers have the requested ledger.</li>
</ul>
<h2 id="ledger-accept">ledger_accept</h2>
<p><a href="https://github.com/ripple/rippled/blob/a61ffab3f9010d8accfaa98aa3cacc7d38e74121/src/ripple/rpc/handlers/LedgerAccept.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>ledger_accept</code> method forces the server to close the current-working ledger and move to the next ledger number. This method is intended for testing purposes only, and is only available when the <code>rippled</code> server is running stand-alone mode.</p>
<p><em>The <code>ledger_accept</code> method is an admin command that cannot be run by unpriviledged users!</em></p>
<h4 id="request-format-15">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:80


*Commandline*

wzxhzdk:81


</div>
<p>The request accepts no parameters.</p>
<h4 id="response-format-15">Response Format</h4>
<p>An example of a successful response:</p>
<pre><code class="js">{
  "id": "Accept my ledger!",
  "status": "success",
  "type": "response",
  "result": {
    "ledger_current_index": 6643240
  }
}
</code></pre>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following field:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ledger_current_index</td>
<td>Unsigned Integer</td>
<td>Sequence number of the newly created 'current' ledger</td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong> When you close a ledger, <code>rippled</code> determines the canonical order of transactions in that ledger and replays them. This can change the outcome of transactions that were provisionally applied to the current ledger.</p>
<h4 id="possible-errors-15">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>notStandAlone</code> - If the <code>rippled</code> server is not currently running in stand-alone mode.</li>
</ul>
<h1 id="transactions">Transactions</h1>
<p>Transactions are the only thing that can modify the shared global ledger of the Ripple Network. All business on the Ripple Network takes the form of transactions, which include not only payments, but also currency-exchange offers, account settings, and changes to the properties of the network itself (like adopting new features).</p>
<p>There are several sources of complication in transactions. Unlike traditional banking, where a trusted third party (the bank, or the <a href="http://en.wikipedia.org/wiki/Automated_Clearing_House">ACH</a>) verifies the participants' identities and ensures their balances are adjusted accurately, Ripple uses cryptography and decentralized computing power to accomplish the same thing. Sending XRP, the Ripple Network's native crypto-currency, requires no third party aside from the distributed network itself. However, that is missing out on the key feature of Ripple: unlike individual crypto-currencies, the Ripple Network natively supports balances in any currency. This brings far more power, but it also means that the system must account for <a href="http://en.wikipedia.org/wiki/Counterparty_risk#Counterparty_risk">counterparty risk</a>, currency conversions, and other issues. The Ripple Network must be robust to keep track of which transactions have been completely validated, even when subject to hardware failures, attacks, or natural disasters.</p>
<h2 id="tx">tx</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/Tx.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>tx</code> method retrieves information on a single transaction. </p>
<h4 id="request-format-16">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:83

*JSON-RPC*

wzxhzdk:84

*Commandline*

wzxhzdk:85


</div>
<p><a class="button" href="ripple-api-tool.html#tx">Try it! &gt;</a></p>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>transaction</td>
<td>String</td>
<td>The 256-bit hash of the transaction, as hex.</td>
</tr>
<tr>
<td>binary</td>
<td>Boolean</td>
<td>(Optional, defaults to false) If true, return transaction data and metadata as hex strings instead of JSON</td>
</tr>
</tbody>
</table>
<h4 id="response-format-16">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:86


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the fields of the <a href="transactions.html">Transaction object</a> as well as the following additional fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td>String</td>
<td>The SHA-512 hash of the transaction</td>
</tr>
<tr>
<td>inLedger</td>
<td>Unsigned Integer</td>
<td>(Deprecated) Alias for <code>ledger_index</code>.</td>
</tr>
<tr>
<td>ledger_index</td>
<td>Unsigned Integer</td>
<td>The sequence number of the ledger that includes this transaction.</td>
</tr>
<tr>
<td>meta</td>
<td>Object</td>
<td>Various metadata about the transaction.</td>
</tr>
<tr>
<td>validated</td>
<td>Boolean</td>
<td>True if this data is from a validated ledger version; if omitted or set to false, this data is not final.</td>
</tr>
<tr>
<td>(Various)</td>
<td>(Various)</td>
<td>Other fields from the <a href="transactions.html">Transaction object</a></td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-16">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>txnNotFound</code> - Either the transaction does not exist, or it was part of an older ledger version that <code>rippled</code> does not have available.</li>
</ul>
<h2 id="transaction-entry">transaction_entry</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/TransactionEntry.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>transaction_entry</code> method retrieves information on a single transaction from a specific ledger version. (The <a href="#tx"><code>tx</code></a> command, by contrast, searches all ledgers for the specified transaction. We recommend using that method instead.) </p>
<h4 id="request-format-17">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:87


*JSON-RPC*


wzxhzdk:88


*Commandline*


wzxhzdk:89


</div>
<p><a class="button" href="ripple-api-tool.html#transaction_entry">Try it! &gt;</a></p>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(Optional) A 20-byte hex string for the ledger version to use. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>ledger_index</td>
<td>String or Unsigned Integer</td>
<td>(Optional) The sequence number of the ledger to use, or a shortcut string to choose a ledger automatically. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>tx_hash</td>
<td>String</td>
<td>Unique hash of the transaction you are looking up</td>
</tr>
</tbody>
</table>
<p><strong><em>Note:</em></strong> This method does not support retrieving information from the current in-progress ledger. You must specify a ledger version in either <code>ledger_index</code> or <code>ledger_hash</code>. </p>
<h4 id="response-format-17">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:90


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ledger_index</td>
<td>Unsigned Integer</td>
<td>Sequence number of the ledger version the transaction was found in; this is the same as the one from the request.</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(May be omitted) Unique hash of the ledger version the transaction was found in; this is the same as the one from the request.</td>
</tr>
<tr>
<td>metadata</td>
<td>Object</td>
<td>Various metadata about the transaction.</td>
</tr>
<tr>
<td>tx_json</td>
<td>Object</td>
<td>JSON representation of the <a href="transactions.html">Transaction object</a></td>
</tr>
</tbody>
</table>
<p>There are a couple possible reasons the server may fail to find the transaction:</p>
<ul>
<li>The transaction just does not exist</li>
<li>The transaction exists, but not in the specified ledger version</li>
<li>The server does not have the specified ledger version available. Another server that has the correct version on hand may have a different response.</li>
</ul>
<h4 id="possible-errors-17">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>fieldNotFoundTransaction</code> - The <code>tx_hash</code> field was omitted from the request</li>
<li><code>notYetImplemented</code> - A ledger version was not specified in the request.</li>
<li><code>lgrNotFound</code> - The ledger specified by the <code>ledger_hash</code> or <code>ledger_index</code> does not exist, or it does exist but the server does not have it.</li>
<li><code>transactionNotFound</code> - The transaction specified in the request could not be found in the specified ledger. (It might be in a different ledger version, or it might not be available at all.)</li>
</ul>
<!-- I think ledgerNotFound ( https://github.com/ripple/rippled/blob/develop/src/ripple/rpc/handlers/TransactionEntry.cpp#L62 ) should not occur because lookupLedger would have errored out first. -->
<h2 id="tx-history">tx_history</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/TxHistory.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>tx_history</code> method retrieves a selection of the most recent transactions made.</p>
<p><strong><em>Caution:</em></strong> This method is deprecated, and may be removed without further notice.</p>
<h4 id="request-format-18">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:91


*JSON-RPC*

wzxhzdk:92


*Commandline*

wzxhzdk:93


</div>
<p><a class="button" href="ripple-api-tool.html#tx_history">Try it! &gt;</a></p>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>start</td>
<td>Unsigned Integer</td>
<td>Number of transactions to skip over.</td>
</tr>
</tbody>
</table>
<h4 id="response-format-18">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:94


*JSON-RPC*

wzxhzdk:95


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>Unsigned Integer</td>
<td>The value of <code>start</code> used in the request.</td>
</tr>
<tr>
<td>txs</td>
<td>Array</td>
<td>Array of transaction objects.</td>
</tr>
</tbody>
</table>
<p>The fields included in each transaction object vary slightly depending on the type of transaction. See <a href="transactions.html">Transaction Format</a> for details.</p>
<h4 id="possible-errors-18">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>noPermission</code> - The <code>start</code> field specified was greater than 10000, but you are not connected to the server as an admin.</li>
</ul>
<h2 id="path-find">path_find</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/PathFind.cpp" title="Source">[Source]<br/></a></p>
<p><em>WebSocket API only!</em> The <code>path_find</code> method searches for a path along which a transaction can possibly be made, and periodically sends updates when the path changes over time. For a simpler version that is supported by JSON-RPC, see <a href="#ripple-path-find"><code>ripple_path_find</code></a>. For payments occurring strictly in XRP, it is not necessary to find a path, because XRP can be sent directly to any account. </p>
<p>There are three different modes, or sub-commands, of the path_find command. Specify which one you want with the <code>subcommand</code> parameter:</p>
<ul>
<li><code>create</code> - Start sending pathfinding information </li>
<li><code>close</code> - Stop sending pathfinding information</li>
<li><code>status</code> - Get the information of the currently-open pathfinding request</li>
</ul>
<p>Although the <code>rippled</code> server attempts to find the cheapest path or combination of paths for making a payment, it is not guaranteed that the paths returned by this method are, in fact, the best paths. Due to server load, pathfinding may not find the best results. Additionally, you should be careful with the pathfinding results from untrusted servers. A server could be modified to return less-than-optimal paths in order to earn money for its operators. If you do not have your own server that you can trust with pathfinding, you should compare the results of pathfinding from multiple servers operated by different parties, to minimize the risk of a single server returning poor results. (<strong><em>Note:</em></strong> A server returning less-than-optimal results is not necessarily proof of malicious behavior; it could also be a symptom of heavy server load.)</p>
<h3 id="path-find-create">path_find create</h3>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/PathFind.cpp#L38" title="Source">[Source]<br/></a></p>
<p>The <code>create</code> subcommand of <code>path_find</code> creates an ongoing request to find possible paths along which a payment transaction could be made from one specified account such that another account receives a desired amount of some currency. The initial response contains a suggested path between the two addresses that would result in the desired amount being received. After that, the server sends additional messages, with <code>"type": "path_find"</code>, with updates to the potential paths. The frequency of updates is left to the discretion of the server, but it usually means once every few seconds when there is a new ledger version.</p>
<p>A client can only have one pathfinding request open at a time. If another pathfinding request is already open on the same connection, the old request is automatically closed and replaced with the new request.</p>
<h4 id="request-format-19">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:96


</div>
<p><a class="button" href="ripple-api-tool.html#path_find">Try it! &gt;</a></p>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>subcommand</td>
<td>String</td>
<td>Use <code>"create"</code> to send the create subcommand</td>
</tr>
<tr>
<td>source_account</td>
<td>String</td>
<td>Unique address of the account to find a path from. (In other words, the account that would be sending a payment.)</td>
</tr>
<tr>
<td>destination_account</td>
<td>String</td>
<td>Unique address of the account to find a path to. (In other words, the account that would receive a payment.)</td>
</tr>
<tr>
<td>destination_amount</td>
<td>String or Object</td>
<td><a href="#specifying-currency-amounts">Currency amount</a> that the destination account would receive in a transaction. <strong>Special case:</strong> <em>(New in <a href="https://github.com/ripple/rippled/releases/tag/0.30.0">rippled 0.30.0</a>)</em> You can specify <code>"-1"</code> (for XRP) or provide -1 as the contents of the <code>value</code> field (for non-XRP currencies). This requests a path to deliver as much as possible, while spending no more than the amount specified in <code>send_max</code> (if provided).</td>
</tr>
<tr>
<td>send_max</td>
<td>String or Object</td>
<td>(Optional) <a href="#specifying-currency-amounts">Currency amount</a> that would be spent in the transaction. Not compatible with <code>source_currencies</code>. <em>(New in <a href="https://github.com/ripple/rippled/releases/tag/0.30.0">rippled 0.30.0</a>)</em></td>
</tr>
<tr>
<td>paths</td>
<td>Array</td>
<td>(Optional) Array of arrays of objects, representing paths to confirm. You can use this to keep updated on changes to particular paths you already know about, or to check the overall cost to make a payment along a certain path.</td>
</tr>
</tbody>
</table>
<p>The server also recognizes the following fields, but the results of using them are not guaranteed: <code>source_currencies</code>, <code>bridges</code>. These fields should be considered reserved for future use.</p>
<h4 id="response-format-19">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:97


</div>
<p>The initial response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>alternatives</td>
<td>Array</td>
<td>Array of objects with suggested paths to take, as described below. If empty, then no paths were found connecting the source and destination accounts.</td>
</tr>
<tr>
<td>destination_account</td>
<td>String</td>
<td>Unique address of the account that would receive a transaction</td>
</tr>
<tr>
<td>destination_amount</td>
<td>String or Object</td>
<td><a href="#specifying-currency-amounts">Currency amount</a> that the destination would receive in a transaction</td>
</tr>
<tr>
<td>id</td>
<td>(Various)</td>
<td>(WebSocket only) The ID provided in the WebSocket request is included again at this level.</td>
</tr>
<tr>
<td>source_account</td>
<td>String</td>
<td>Unique address of the account that would initiate a transaction</td>
</tr>
<tr>
<td>full_reply</td>
<td>Boolean</td>
<td>If <code>false</code>, this is the result of an incomplete search, and a subsequent reply may have a better path. If <code>true</code>, then this is the best path found. (It is still theoretically possible that a better path could exist, but rippled won't find it.) Until you close the pathfinding request, rippled will continue to send updates each time a new ledger closes. <em>(New in <a href="https://github.com/ripple/rippled/releases/tag/0.29.0">rippled 0.29.0</a>)</em></td>
</tr>
</tbody>
</table>
<p>Each element in the <code>alternatives</code> array is an object that represents a path from one possible source currency (held by the initiating account) to the destination account and currency. This object has the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>paths_computed</td>
<td>Array</td>
<td>Array of arrays of objects defining <a href="paths.html">payment paths</a></td>
</tr>
<tr>
<td>source_amount</td>
<td>String or Object</td>
<td><a href="#specifying-currency-amounts">Currency amount</a> that the source would have to send along this path in order for the destination to receive the desired amount</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-19">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>noEvents</code> - You are using a protocol that does not support asynchronous callbacks, for example JSON-RPC. (See <a href="#ripple-path-find">ripple_path_find</a> for a pathfinding method that <em>is</em> compatible with JSON-RPC.)</li>
</ul>
<h4 id="asynchronous-follow-ups">Asynchronous Follow-ups</h4>
<p>In addition to the initial response, the server sends more messages in a similar format to update on the status of the paths over time. These messages include the <code>id</code> of the original WebSocket request so you can tell which request prompted them, and the field <code>"type": "path_find"</code> at the top level to indicate that they are additional responses. The other fields are defined in the same way as the initial response.</p>
<p>If the follow-up includes <code>"full_reply": true</code>, then this is the best path that rippled can find as of the current ledger.</p>
<p>Here is an example of an asychronous follow-up from a path_find create request:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:98


</div>
<h3 id="path-find-close">path_find close</h3>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/PathFind.cpp#L46" title="Source">[Source]<br/></a></p>
<p>The <code>close</code> subcommand of <code>path_find</code> instructs the server to stop sending information about the current open pathfinding request.</p>
<h4 id="request-format-20">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:99


</div>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>subcommand</td>
<td>String</td>
<td>Use <code>"close"</code> to send the close subcommand</td>
</tr>
</tbody>
</table>
<h4 id="response-format-20">Response Format</h4>
<p>If a pathfinding request was successfully closed, the response follows the same format as the initial response to <a href="#path-find-create"><code>path_find create</code></a>, plus the following field:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>closed</td>
<td>Boolean</td>
<td>The value <code>true</code> indicates this reply is in response to a <code>path_find close</code> command.</td>
</tr>
</tbody>
</table>
<p>If there was no outstanding pathfinding request, an error is returned instead.</p>
<h4 id="possible-errors-20">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - If any fields are specified incorrectly, or any required fields are missing.</li>
<li><code>noEvents</code> - If you tried to use this method on a protocol that does not support asynchronous callbacks, for example JSON-RPC. (See <a href="#ripple-path-find">ripple_path_find</a> for a pathfinding method that <em>is</em> compatible with JSON-RPC.)</li>
<li><code>noPathRequest</code> - You tried to close a pathfinding request when there is not an open one.</li>
</ul>
<h3 id="path-find-status">path_find status</h3>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/PathFind.cpp#L57" title="Source">[Source]<br/></a></p>
<p>The <code>status</code> subcommand of <code>path_find</code> requests an immediate update about the client's currently-open pathfinding request.</p>
<h4 id="request-format-21">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:100


</div>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>subcommand</td>
<td>String</td>
<td>Use <code>"status"</code> to send the status subcommand</td>
</tr>
</tbody>
</table>
<h4 id="response-format-21">Response Format</h4>
<p>If a pathfinding request is open, the response follows the same format as the initial response to <a href="#path-find-create"><code>path_find create</code></a>, plus the following field:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>status</td>
<td>Boolean</td>
<td>The value <code>true</code> indicates this reply is in response to a <code>path_find status</code> command.</td>
</tr>
</tbody>
</table>
<p>If there was no outstanding pathfinding request, an error is returned instead.</p>
<h4 id="possible-errors-21">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>noEvents</code> - You are using a protocol that does not support asynchronous callbacks, for example JSON-RPC. (See <a href="#ripple-path-find">ripple_path_find</a> for a pathfinding method that <em>is</em> compatible with JSON-RPC.)</li>
<li><code>noPathRequest</code> - You tried to check the status of a pathfinding request when there is not an open one.</li>
</ul>
<h2 id="ripple-path-find">ripple_path_find</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/RipplePathFind.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>ripple_path_find</code> method is a simplified version of <a href="#path-find"><code>path_find</code></a> that provides a single response to be used to make a payment transaction immediately. It is available in both the WebSocket and JSON-RPC APIs. However, the results tend to become outdated as time passes. Instead of making many subsequent calls, you should use <a href="#path-find"><code>path_find</code></a> instead where possible.</p>
<p>Although the <code>rippled</code> server attempts to find the cheapest path or combination of paths for making a payment, it is not guaranteed that the paths returned by this method are, in fact, the best paths. Due to server load, pathfinding may not find the best results. Additionally, you should be careful with the pathfinding results from untrusted servers. A server could be modified to return less-than-optimal paths in order to earn money for its operators. If you do not have your own server that you can trust with pathfinding, you should compare the results of pathfinding from multiple servers operated by different parties, to minimize the risk of a single server returning poor results. (<strong><em>Note:</em></strong> A server returning less-than-optimal results is not necessarily proof of malicious behavior; it could also be a symptom of heavy server load.)</p>
<h4 id="request-format-22">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:101


*JSON-RPC*


wzxhzdk:102


*Commandline*


wzxhzdk:103


</div>
<p><a class="button" href="ripple-api-tool.html#ripple_path_find">Try it! &gt;</a></p>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>source_account</td>
<td>String</td>
<td>Unique address of the account that would send funds in a transaction</td>
</tr>
<tr>
<td>destination_account</td>
<td>String</td>
<td>Unique address of the account that would receive funds in a transaction</td>
</tr>
<tr>
<td>destination_amount</td>
<td>String or Object</td>
<td><a href="#specifying-currency-amounts">Currency amount</a> that the destination account would receive in a transaction. <strong>Special case:</strong> <em>(New in <a href="https://github.com/ripple/rippled/releases/tag/0.28.2">rippled 0.30.0</a>)</em> You can specify <code>"-1"</code> (for XRP) or provide -1 as the contents of the <code>value</code> field (for non-XRP currencies). This requests a path to deliver as much as possible, while spending no more than the amount specified in <code>send_max</code> (if provided).</td>
</tr>
<tr>
<td>send_max</td>
<td>String or Object</td>
<td>(Optional) <a href="#specifying-currency-amounts">Currency amount</a> that would be spent in the transaction. Not compatible with <code>source_currencies</code>. <em>(New in <a href="https://github.com/ripple/rippled/releases/tag/0.28.2">rippled 0.30.0</a>)</em></td>
</tr>
<tr>
<td>source_currencies</td>
<td>Array</td>
<td>(Optional, defaults to all available) Array of currencies that the source account might want to spend. Each entry in the array should be a JSON object with a mandatory <code>currency</code> field and optional <code>issuer</code> field, similar to <a href="#specifying-currency-amounts">currency amounts</a>.</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(Optional) A 20-byte hex string for the ledger version to use. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>ledger_index</td>
<td>String or Unsigned Integer</td>
<td>(Optional) The sequence number of the ledger to use, or a shortcut string to choose a ledger automatically. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
</tbody>
</table>
<h4 id="response-format-22">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:104


*JSON-RPC*


wzxhzdk:105


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>alternatives</td>
<td>Array</td>
<td>Array of objects with possible paths to take, as described below. If empty, then there are no paths connecting the source and destination accounts.</td>
</tr>
<tr>
<td>destination_account</td>
<td>String</td>
<td>Unique address of the account that would receive a payment transaction</td>
</tr>
<tr>
<td>destination_currencies</td>
<td>Array</td>
<td>Array of strings representing the currencies that the destination accepts, as 3-letter codes like <code>"USD"</code> or as 40-character hex like <code>"015841551A748AD2C1F76FF6ECB0CCCD00000000"</code></td>
</tr>
</tbody>
</table>
<p>Each element in the <code>alternatives</code> array is an object that represents a path from one possible source currency (held by the initiating account) to the destination account and currency. This object has the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>paths_computed</td>
<td>Array</td>
<td>Array of arrays of objects defining <a href="paths.html">payment paths</a></td>
</tr>
<tr>
<td>source_amount</td>
<td>String or Object</td>
<td><a href="#specifying-currency-amounts">Currency amount</a> that the source would have to send along this path in order for the destination to receive the desired amount</td>
</tr>
</tbody>
</table>
<p>The following fields are deprecated, and may be omitted: <code>paths_canonical</code>, and <code>paths_expanded</code>. If they appear, you should disregard them.</p>
<h4 id="possible-errors-22">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>tooBusy</code> - The server is under too much load to calculate paths. Not returned if you are connected as an admin.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>srcActMissing</code> - The <code>source_account</code> field is omitted from the request.</li>
<li><code>srcActMalformed</code> - The <code>source_account</code> field in the request is not formatted properly.</li>
<li><code>dstActMissing</code> - The <code>destination_account</code> field is omitted from the request.</li>
<li><code>dstActMalformed</code> - The <code>destination_account</code> field in the request is not formatted properly.</li>
<li><code>srcCurMalformed</code> - The <code>source_currencies</code> field is not formatted properly.</li>
<li><code>srcIsrMalformed</code> - The <code>issuer</code> field of one or more of the currency objects in the request is not valid.</li>
</ul>
<h2 id="sign">sign</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/SignHandler.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>sign</code> method takes a transaction, specified as JSON, and a secret key, and returns a signed binary representation of the transaction that can be submitted. The result is always different, even when you provide the same transaction JSON and secret key.</p>
<p><strong><em>Note:</em></strong> It is possible and preferable to sign a transaction without connecting to a server instead of using this command, by using <a href="https://github.com/ripple/ripple-lib">ripple-lib</a>. You should prefer to do offline signing of a transaction, especially when you do not control the server you are sending a transaction to. An untrustworthy server can abuse its position to change the transaction before signing it, or worse, use your secret to sign additional arbitrary transactions as if they came from you.</p>
<h4 id="request-format-23">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:106


*JSON-RPC*

wzxhzdk:107


*Commandline*

wzxhzdk:108


</div>
<p><a class="button" href="ripple-api-tool.html#sign">Try it! &gt;</a></p>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tx_json</td>
<td>Object</td>
<td><a href="transactions.html">Transaction definition</a> in JSON format</td>
</tr>
<tr>
<td>secret</td>
<td>String</td>
<td>Secret key of the account supplying the transaction, used to sign it. Do not send your secret to untrusted servers or through unsecured network connections.</td>
</tr>
<tr>
<td>offline</td>
<td>Boolean</td>
<td>(Optional, defaults to false) If true, when constructing the transaction, do not attempt to automatically fill in or validate values.</td>
</tr>
<tr>
<td>build_path</td>
<td>Boolean</td>
<td>(Optional) If provided for a Payment-type transaction, automatically fill in the <code>Paths</code> field before signing. <strong><em>Caution:</em></strong> The server looks for the presence or absence of this field, not its value. This behavior may change. (See <a href="https://ripplelabs.atlassian.net/browse/RIPD-173">RIPD-173</a> for status.)</td>
</tr>
<tr>
<td>fee_mult_max</td>
<td>Integer</td>
<td>(Optional) If the <code>Fee</code> parameter (<a href="tx-cost.html">transaction cost</a>) is omitted, this field limits the automatically-provided value so that it is less than or equal to the base transaction cost times this value.</td>
</tr>
</tbody>
</table>
<p>The server automatically attempts to fill in certain fields from the <code>tx_json</code> object if they are omitted, unless you specified <code>offline</code> as true. Otherwise, the following fields from the <a href="transactions.html">transaction format</a> are automatically filled in:</p>
<ul>
<li><code>Sequence</code> - The server automatically uses the next Sequence number from the sender's account information. Be careful: the next sequence number for the account is not incremented until this transaction is applied. If you sign multiple transactions without submitting and waiting for the response to each one, you must provide the correct sequence numbers in the request. Automatically filled unless <code>offline</code> is true.</li>
<li><code>Fee</code> - If you omit the <code>Fee</code> parameter, the server <a href="tx-cost.html#automatically-specifying-the-transaction-cost">automatically provides an appropriate transaction cost</a> unless you specified <code>offline</code> as true. If you specify <code>offline</code> as true, you must fill in the transaction cost in the <code>Fee</code> parameter. Be careful: a malicious server can specify an excessively high transaction cost.<ul>
<li>If <code>fee_mult_max</code> is included, and the automatically provided <code>Fee</code> value is greater than the long-term base transaction cost times <code>fee_mult_max</code>, then the transaction fails with the error <code>rpcHIGH_FEE</code>. This way, you can let the server fill in the current minimum <code>Fee</code> value as long as the current load-based transaction cost is not too high.</li>
</ul>
</li>
<li><code>Paths</code> - For Payment-type transactions (excluding XRP-to-XRP transfers), the Paths field can be automatically filled, as if you did a <a href="#ripple-path-find">ripple_path_find</a>. Only filled if <code>build_path</code> is provided. </li>
</ul>
<h4 id="response-format-23">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:109


*JSON-RPC*

wzxhzdk:110


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tx_blob</td>
<td>String</td>
<td>Binary representation of the fully-qualified, signed transaction, as hex</td>
</tr>
<tr>
<td>tx_json</td>
<td>Object</td>
<td>JSON specification of the <a href="transactions.html">complete transaction</a> as signed, including any fields that were automatically filled in</td>
</tr>
</tbody>
</table>
<p><strong><em>Caution:</em></strong> If this command results in an error messages, the message can contain the account secret from the request. Make sure that these errors are not visible to others, including:</p>
<ul>
<li>Do not write this error to a log file that can be seen by multiple people</li>
<li>Do not paste this error to a public place for debugging</li>
<li>Do not display the error message on a website, even by accident</li>
</ul>
<h4 id="possible-errors-23">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>highFee</code> - The <code>fee_mult_max</code> parameter was specified, but the server's current transaction cost multiplier exceeds the specified one.</li>
<li><code>tooBusy</code> - The transaction did not include paths, but the server is too busy to do pathfinding right now. Does not occur if you are connected as an admin.</li>
<li><code>noPath</code> - The transaction did not include paths, and the server was unable to find a path by which this payment can occur.</li>
</ul>
<h2 id="submit">submit</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/Submit.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>submit</code> method sends a <a href="transactions.html">transaction</a> to the network to be confirmed and included in future ledgers. </p>
<p>This command has two modes:</p>
<ul>
<li>Submit-only mode takes a signed, serialized transaction as a binary blob, and submits it to the network as-is. Since signed transaction objects are immutable, no portion of the transaction can be modified or automatically filled in after submission.</li>
<li>Sign-and-submit mode takes a JSON-formatted Transaction object, completes and signs the transaction in the same manner as the <a href="#sign">sign command</a>, and then submits the signed transaction. We recommend only using this mode for testing and development.</li>
</ul>
<p>To send a transaction as robustly as possible, you should construct and <a href="#sign"><code>sign</code></a> it in advance, persist it somewhere that you can access even after a power outage, then <code>submit</code> it as a <code>tx_blob</code>. After submission, monitor the network with the <a href="#tx"><code>tx</code></a> command to see if the transaction was successfully applied; if a restart or other problem occurs, you can safely re-submit the <code>tx_blob</code> transaction: it won't be applied twice since it has the same sequence number as the old transaction. </p>
<h3 id="submit-only-mode">Submit-Only Mode</h3>
<p>A submit-only request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tx_blob</td>
<td>String</td>
<td>Hex representation of the signed transaction to submit.</td>
</tr>
<tr>
<td>fail_hard</td>
<td>Boolean</td>
<td>(Optional, defaults to false) If true, and the transaction fails locally, do not retry or relay the transaction to other servers</td>
</tr>
</tbody>
</table>
<h4 id="request-format-24">Request Format</h4>
<div class="multicode">

*WebSocket*

wzxhzdk:111


*JSON-RPC*

wzxhzdk:112


*Commandline*

wzxhzdk:113


</div>
<p><a class="button" href="ripple-api-tool.html#submit">Try it! &gt;</a></p>
<h3 id="sign-and-submit-mode">Sign-and-Submit Mode</h3>
<p>A sign-and-submit request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tx_json</td>
<td>Object</td>
<td><a href="transactions.html">Transaction definition</a> in JSON format, optionally omitting any auto-fillable fields.</td>
</tr>
<tr>
<td>secret</td>
<td>String</td>
<td>(Required if <code>tx_json</code> is supplied) Secret key of the account supplying the transaction, used to sign it. Do not send your secret to untrusted servers or through unsecured network connections.</td>
</tr>
<tr>
<td>fail_hard</td>
<td>Boolean</td>
<td>(Optional, defaults to false) If true, and the transaction fails locally, do not retry or relay the transaction to other servers</td>
</tr>
<tr>
<td>offline</td>
<td>Boolean</td>
<td>(Optional, defaults to false) If true, when constructing the transaction, do not attempt to automatically fill in or validate values.</td>
</tr>
<tr>
<td>build_path</td>
<td>Boolean</td>
<td>(Optional) If provided for a Payment-type transaction, automatically fill in the <code>Paths</code> field before signing. You must omit this field if the transaction is a direct XRP-to-XRP transfer. <strong><em>Caution:</em></strong> The server looks for the presence or absence of this field, not its value. This behavior may change. (See <a href="https://ripplelabs.atlassian.net/browse/RIPD-173">RIPD-173</a> for status.)</td>
</tr>
<tr>
<td>fee_mult_max</td>
<td>Integer</td>
<td>(Optional) If the <code>Fee</code> parameter is omitted, this field limits the automatically-provided <code>Fee</code> value so that it is less than or equal to the long-term base transaction cost times this value.</td>
</tr>
</tbody>
</table>
<p>See the <a href="#sign">sign command</a> for detailed information on how the server automatically fills in certain fields.</p>
<h4 id="request-format-25">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:114


*JSON-RPC*

wzxhzdk:115


*Commandline*

wzxhzdk:116


</div>
<p><a class="button" href="ripple-api-tool.html#submit">Try it! &gt;</a></p>
<h4 id="response-format-24">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:117


*JSON-RPC*

wzxhzdk:118


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>engine_result</td>
<td>String</td>
<td>Code indicating the status of the transaction, for example <code>tesSUCCESS</code></td>
</tr>
<tr>
<td>engine_result_code</td>
<td>Integer</td>
<td>Numeric code indicating the status of the transaction, directly correlated to <code>engine_result</code></td>
</tr>
<tr>
<td>engine_result_message</td>
<td>String</td>
<td>Human-readable explanation of the status of the transaction</td>
</tr>
<tr>
<td>tx_blob</td>
<td>String</td>
<td>The complete transaction in hex string format</td>
</tr>
<tr>
<td>tx_json</td>
<td>Object</td>
<td>The complete transaction in JSON format</td>
</tr>
</tbody>
</table>
<p><strong><em>Caution:</em></strong> Even if the WebSocket response has <code>"status":"success"</code>, indicating that the command was successfully received, that does not necessarily indicate that the transaction has taken place. There are many cases that can prevent a transaction from processing successfully, such as a lack of trust lines connecting the two accounts in a payment, or changes in the state of the network since the time the transaction was constructed. Even if nothing is wrong, it may take several seconds to close and validate the ledger version that includes the transaction. See the <a href="transactions.html#full-transaction-response-list">full list of transaction responses</a> for details, and do not consider the transaction's results final until they appear in a validated ledger version.</p>
<p><strong><em>Caution:</em></strong> If this command results in an error messages, the message can contain an account secret, if one was provided in the request. (This is not a problem if the request contained a signed tx_blob instead.) Make sure that these errors are not visible to others, including:</p>
<ul>
<li>Do not write an error including your secret to a log file that can be seen by multiple people</li>
<li>Do not paste an error including your secret to a public place for debugging</li>
<li>Do not display an error message including your secret on a website, even by accident</li>
</ul>
<h4 id="possible-errors-24">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidTransaction</code> - The transaction is malformed or otherwise invalid.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>highFee</code> - The <code>fee_mult_max</code> parameter was specified, but the server's current fee multiplier exceeds the specified one. (Sign-and-Submit mode only)</li>
<li><code>tooBusy</code> - The transaction did not include paths, but the server is too busy to do pathfinding right now. Does not occur if you are connected as an admin. (Sign-and-Submit mode only)</li>
<li><code>noPath</code> - The transaction did not include paths, and the server was unable to find a path by which this payment can occur. (Sign-and-Submit mode only)</li>
<li><code>internalTransaction</code> - An internal error occurred when processing the transaction. This could be caused by many aspects of the transaction, including a bad signature or some fields being malformed.</li>
<li><code>internalSubmit</code> - An internal error occurred when submitting the transaction. This could be caused by many aspects of the transaction, including a bad signature or some fields being malformed.</li>
<li><code>internalJson</code> - An internal error occurred when serializing the transaction to JSON. This could be caused by many aspects of the transaction, including a bad signature or some fields being malformed.</li>
</ul>
<h2 id="book-offers">book_offers</h2>
<p><a href="https://github.com/ripple/rippled/blob/develop/src/ripple/rpc/handlers/BookOffers.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>book_offers</code> method retrieves a list of offers, also known as the <a href="http://www.investopedia.com/terms/o/order-book.asp">order book</a>, between two currencies. If the results are very large, a partial result is returned with a marker so that subsequent requests can resume from where the previous one left off.</p>
<h4 id="request-format-26">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:119


*JSON-RPC*


wzxhzdk:120


*Commandline*


wzxhzdk:121


</div>
<p><a class="button" href="ripple-api-tool.html#book_offers">Try it! &gt;</a></p>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(Optional) A 20-byte hex string for the ledger version to use. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>ledger_index</td>
<td>String or Unsigned Integer</td>
<td>(Optional) The sequence number of the ledger to use, or a shortcut string to choose a ledger automatically. (See <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>)</td>
</tr>
<tr>
<td>limit</td>
<td>Unsigned Integer</td>
<td>(Optional) If provided, the server will not provide more than this many offers in the results. <em>Note:</em> Depending on the number of unfunded orders in the ledger, fewer results may be returned.</td>
</tr>
<tr>
<td>taker</td>
<td>String</td>
<td>(Optional, defaults to <a href="https://ripple.com/wiki/Accounts#ACCOUNT_ONE">ACCOUNT_ONE</a>) Unique base-58 address of an account to use as point-of-view. (This affects which unfunded offers are returned.)</td>
</tr>
<tr>
<td>taker_gets</td>
<td>Object</td>
<td>Specification of which currency the account taking the offer would receive, as an object with <code>currency</code> and <code>issuer</code> fields (omit issuer for XRP), similar to <a href="#specifying-currency-amounts">currency amounts</a>.</td>
</tr>
<tr>
<td>taker_pays</td>
<td>Object</td>
<td>Specification of which currency the account taking the offer would pay, as an object with <code>currency</code> and <code>issuer</code> fields (omit issuer for XRP), similar to <a href="#specifying-currency-amounts">currency amounts</a>.</td>
</tr>
</tbody>
</table>
<p><strong><em>Note:</em></strong> The other parameters of this command (<code>marker</code>, <code>proof</code>, and <code>autobridge</code>) cannot be fully implemented with the current design. (See <a href="https://ripplelabs.atlassian.net/browse/RIPD-295">RIPD-295</a> for more information).</p>
<p>Normally, offers that are not funded are omitted; however, offers made by the specified <code>taker</code> account are always displayed. This allows you to look up your own unfunded offers in order to cancel them with an OfferCancel transaction.</p>
<h4 id="response-format-25">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:122


*JSON-RPC*

wzxhzdk:123


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ledger_current_index</td>
<td>Integer</td>
<td>(Omitted if ledger version provided) Sequence number of the ledger version used when retrieving this data.</td>
</tr>
<tr>
<td>ledger_index</td>
<td>Integer</td>
<td>(Omitted if ledger_current_index provided instead) Sequence number, provided in the request, of the ledger version that was used when retrieving this data.</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(May be omitted) Hex hash, provided in the request, of the ledger version that was used when retrieving this data.</td>
</tr>
<tr>
<td>offers</td>
<td>Array</td>
<td>Array of offer objects, each of which has the fields of an <a href="transactions.html#offercreate">OfferCreate transaction</a></td>
</tr>
</tbody>
</table>
<p>In addition to the standard Offer fields, the following fields may be included in members of the <code>offers</code> array:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>taker_gets_funded</td>
<td>String (XRP) or Object (non-XRP)</td>
<td>(Only included in partially-funded offers) The maximum amount of currency that the taker can get, given the funding status of the offer.</td>
</tr>
<tr>
<td>taker_pays_funded</td>
<td>String (XRP) or Object (non-XRP)</td>
<td>(Only included in partially-funded offers) The maximum amount of currency that the taker would pay, given the funding status of the offer.</td>
</tr>
<tr>
<td>quality</td>
<td>Number</td>
<td>The exchange rate, as the ratio <code>taker_pays</code> divided by <code>taker_gets</code>. For fairness, offers that have the same quality are automatically taken first-in, first-out. (In other words, if multiple people offer to exchange currency at the same rate, the oldest offer is taken first.)</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-25">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>lgrNotFound</code> - The ledger specified by the <code>ledger_hash</code> or <code>ledger_index</code> does not exist, or it does exist but the server does not have it.</li>
<li><code>srcCurMalformed</code> - The <code>taker_pays</code> field in the request is not formatted properly.</li>
<li><code>dstAmtMalformed</code> - The <code>taker_gets</code> field in the request is not formatted properly.</li>
<li><code>srcIsrMalformed</code> - The <code>issuer</code> field of the <code>taker_pays</code> field in the request is not valid.</li>
<li><code>dstIsrMalformed</code> - The <code>issuer</code> field of the <code>taker_gets</code> field in the request is not valid.</li>
<li><code>badMarket</code> - The desired order book does not exist; for example, offers to exchange a currency for itself.</li>
</ul>
<h1 id="subscriptions">Subscriptions</h1>
<p>Using subscriptions, you can have the server push updates to your client when various events happen, so that you can know right away and react accordingly. Subscriptions are only supported in the WebSocket API, where you can receive additional responses in the same channel.</p>
<p>JSON-RPC support for subscription callbacks is deprecated and may not work as expected.</p>
<h2 id="subscribe">subscribe</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/Subscribe.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>subscribe</code> method requests periodic notifications from the server when certain events happen. </p>
<h4 id="request-format-27">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket - accounts*

wzxhzdk:124

*WebSocket - offer book*

wzxhzdk:125


</div>
<p><a class="button" href="ripple-api-tool.html#subscribe">Try it! &gt;</a></p>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>streams</td>
<td>Array</td>
<td>(Optional) Array of string names of generic streams to subscribe to, as explained below</td>
</tr>
<tr>
<td>accounts</td>
<td>Array</td>
<td>(Optional) Array with the unique base-58 addresses of accounts to monitor for validated transactions. The server sends a notification for any transaction that affects at least one of these accounts.</td>
</tr>
<tr>
<td>accounts_proposed</td>
<td>Array</td>
<td>(Optional) Like <code>accounts</code>, but include transactions that are not yet finalized.</td>
</tr>
<tr>
<td>books</td>
<td>Array</td>
<td>(Optional) Array of objects defining <a href="http://www.investopedia.com/terms/o/order-book.asp">order books</a> to monitor for updates, as detailed below.</td>
</tr>
<tr>
<td>url</td>
<td>String</td>
<td>(Optional for Websocket; Required otherwise) URL where the server will send a JSON-RPC callback with each event. <em>Admin-only.</em></td>
</tr>
<tr>
<td>url_username</td>
<td>String</td>
<td>(Optional) Username to provide for basic authentication at the callback URL.</td>
</tr>
<tr>
<td>url_password</td>
<td>String</td>
<td>(Optional) Password to provide for basic authentication at the callback URL.</td>
</tr>
</tbody>
</table>
<p>The following parameters are deprecated and may be removed without further notice: <code>user</code>, <code>password</code>, <code>rt_accounts</code>.</p>
<p>The <code>streams</code> parameter provides access to the following default streams of information:</p>
<ul>
<li><code>server</code> - Sends a message whenever the status of the rippled server (for example, network connectivity) changes</li>
<li><code>ledger</code> - Sends a message whenever the consensus process declares a new validated ledger</li>
<li><code>transactions</code> - Sends a message whenever a transaction is included in a closed ledger</li>
<li><code>transactions_proposed</code> - Sends a message whenever a transaction is included in a closed ledger, as well as some transactions that have not yet been included in a validated ledger and may never be. Not all proposed transactions appear before validation, however. (<strong><em>Note:</em></strong> <a href="transactions.html#result-categories">Even some transactions that don't succeed are included</a> in validated ledgers, because they take the anti-spam transaction fee.)</li>
</ul>
<p>Each member of the <code>books</code> array, if provided, is an object with the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>taker_gets</td>
<td>Object</td>
<td>Specification of which currency the account taking the offer would receive, as a <a href="#specifying-currencies-without-amounts">currency object with no amount</a>.</td>
</tr>
<tr>
<td>taker_pays</td>
<td>Object</td>
<td>Specification of which currency the account taking the offer would pay, as a <a href="#specifying-currencies-without-amounts">currency object with no amount</a>.</td>
</tr>
<tr>
<td>taker</td>
<td>String</td>
<td>Unique base-58 account address to use as a perspective for viewing offers. (This affects the funding status and fees of offers.)</td>
</tr>
<tr>
<td>snapshot</td>
<td>Boolean</td>
<td>(Optional, defaults to false) If true, return the current state of the order book once when you subscribe before sending updates</td>
</tr>
<tr>
<td>both</td>
<td>Boolean</td>
<td>(Optional, defaults to false) If true, return both sides of the order book.</td>
</tr>
</tbody>
</table>
<p>The field <code>proof</code> is reserved for future use.</p>
<h4 id="response-format-26">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:126


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>. The fields contained in the response vary depending on what subscriptions were included in the request.</p>
<ul>
<li><code>accounts</code> and <code>accounts_proposed</code> - No fields returned</li>
<li><em>Stream: server</em> - Information about the server status, such as <code>load_base</code> (the current load level of the server), <code>random</code> (a randomly-generated value), and others, subject to change. </li>
<li><em>Stream: transactions</em> and <em>Stream: transactions_proposed</em> - No fields returned</li>
<li><em>Stream: ledger</em> - Information about the ledgers on hand and current fee schedule, such as <code>fee_base</code> (current base fee for transactions in XRP), <code>fee_ref</code> (current base fee for transactions in fee units), <code>ledger_hash</code> (hash of the latest validated ledger), <code>reserve_base</code> (minimum reserve for accounts), and more.</li>
<li><code>books</code> - No fields returned by default. If <code>"snapshot": true</code> is set in the request, returns <code>offers</code> (an array of offer definition objects defining the order book)</li>
</ul>
<h4 id="possible-errors-26">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>noPermission</code> - The request included the <code>url</code> field, but you are not connected as an admin.</li>
<li><code>unknownStream</code> - One or more the members of the <code>streams</code> field in the request was not recognized as a valid stream name.</li>
<li><code>malformedStream</code> - The <code>streams</code> field of the request was not formatted properly.</li>
<li><code>malformedAccount</code> - One of the addresses in the <code>accounts</code> or <code>accounts_proposed</code> fields of the request is not a properly-formatted Ripple address. (<strong><em>Note</em></strong>: You <em>can</em> subscribe to the stream of an address that does not yet have an entry in the global ledger; if your subscription is still active, you will get a message when that account receives the payment that creates it.)</li>
<li><code>srcCurMalformed</code> - One or more <code>taker_pays</code> sub-fields of the <code>books</code> field in the request is not formatted properly.</li>
<li><code>dstAmtMalformed</code> - One or more <code>taker_gets</code> sub-fields of the <code>books</code> field in the request is not formatted properly.</li>
<li><code>srcIsrMalformed</code> - The <code>issuer</code> field of one or more <code>taker_pays</code> sub-fields of the <code>books</code> field in the request is not valid.</li>
<li><code>dstIsrMalformed</code> - The <code>issuer</code> field of one or more <code>taker_gets</code> sub-fields of the <code>books</code> field in the request is not valid.</li>
<li><code>badMarket</code> - One or more desired order books in the <code>books</code> field does not exist; for example, offers to exchange a currency for itself.</li>
</ul>
<h3 id="subscription-stream-messages">Subscription Stream Messages</h3>
<p>When you subscribe to a particular stream, you will receive periodic responses on that stream until you unsubscribe or close the WebSocket connection. The content of those responses depends on what you subscribed to. Here are some examples:</p>
<h4 id="stream-ledger-message">Stream: ledger Message</h4>
<p>The ledger stream only sends <code>ledgerClosed</code> messages when <a href="https://ripple.com/knowledge_center/the-ripple-ledger-consensus-process/">the consensus process</a> declares a new validated ledger. The message identifies the ledger and provides some information about its contents.</p>
<pre><code>{
  "type": "ledgerClosed",
  "fee_base": 10,
  "fee_ref": 10,
  "ledger_hash": "687F604EF6B2F67319E8DCC8C66EF49D84D18A1E18F948421FC24D2C7C3DB464",
  "ledger_index": 7125358,
  "ledger_time": 455751310,
  "reserve_base": 20000000,
  "reserve_inc": 5000000,
  "txn_count": 7,
  "validated_ledgers": "32570-7125358"
}
</code></pre>
<p>The fields from a ledger stream message are as follows:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>String</td>
<td><code>ledgerClosed</code> indicates this is from the ledger stream</td>
</tr>
<tr>
<td>fee_base</td>
<td>Unsigned Integer</td>
<td>Cost of the 'reference transaction' in drops of XRP. (See <a href="tx-cost.html">Transaction Cost</a> If the ledger includes a <a href="transactions.html#setfee">SetFee pseudo-transaction</a> the new transaction cost applies to all transactions after this ledger.</td>
</tr>
<tr>
<td>fee_ref</td>
<td>Unsigned Integer</td>
<td>Cost of the 'reference transaction' in 'fee units'.</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>Unique hash of the ledger that was closed, as hex</td>
</tr>
<tr>
<td>ledger_index</td>
<td>Unsigned Integer</td>
<td>Sequence number of the ledger that was closed</td>
</tr>
<tr>
<td>ledger_time</td>
<td>Unsigned Integer</td>
<td>The time this ledger was closed, in seconds since the <a href="#specifying-time">Ripple Epoch</a></td>
</tr>
<tr>
<td>reserve_base</td>
<td>Unsigned Integer</td>
<td>The minimum reserve, in drops of XRP, that is required for an account. If the ledger includes a <a href="transactions.html#setfee">SetFee pseudo-transaction</a> the new base reserve applies after this ledger.</td>
</tr>
<tr>
<td>reserve_inc</td>
<td>Unsigned Integer</td>
<td>The increase in account reserve that is added for each item the account owns, such as offers or trust lines. If the ledger includes a <a href="transactions.html#setfee">SetFee pseudo-transaction</a> the new owner reserve applies after this ledger.</td>
</tr>
<tr>
<td>txn_count</td>
<td>Unsigned Integer</td>
<td>Number of new transactions included in this ledger</td>
</tr>
<tr>
<td>validated_ledgers</td>
<td>String</td>
<td>Range of ledgers that the server has available. This may be discontiguous.</td>
</tr>
</tbody>
</table>
<h4 id="transaction-messages">Transaction Messages</h4>
<p>Most other subscriptions result in messages about transactions. The <code>transactions_proposed</code> stream, strictly speaking, is a superset of the <code>transactions</code> stream: it includes all validated transactions, as well as some suggested transactions that have not yet been included in a validated ledger and may never be. You can identify these "in-flight" transactions by their fields:</p>
<ul>
<li>The <code>validated</code> field is missing or has a value of <code>false</code>.</li>
<li>There is no <code>meta</code> or <code>metadata</code> field.</li>
<li>Instead of <code>ledger_hash</code> and <code>ledger_index</code> fields specifying in which ledger version the transactions were finalized, there is a <code>ledger_current_index</code> field specifying in which ledger version they are currently proposed.</li>
</ul>
<p>Otherwise, the messages from the <code>transactions_proposed</code> stream are identical to ones from the <code>transactions</code> stream.</p>
<p>Since the only thing that can modify an account or an order book is a transaction, the messages that are sent as a result of subscribing to particular <code>accounts</code> or <code>books</code> also take the form of transaction messages, the same as the ones in the <code>transactions</code> stream. The only difference is that you only receive messages for transactions that affect the accounts or order books you're watching.</p>
<p>The <code>accounts_proposed</code> subscription works the same way, except it also includes unconfirmed transactions, like the <code>transactions_proposed</code> stream, for the accounts you're watching.</p>
<pre><code>{
  "status": "closed",
  "type": "transaction",
  "engine_result": "tesSUCCESS",
  "engine_result_code": 0,
  "engine_result_message": "The transaction was applied.",
  "ledger_hash": "989AFBFD65D820C6BD85301B740F5D592F060668A90EEF5EC1815EBA27D58FE8",
  "ledger_index": 7125442,
  "meta": {
    "AffectedNodes": [
      {
        "ModifiedNode": {
          "FinalFields": {
            "Flags": 0,
            "IndexPrevious": "0000000000000000",
            "Owner": "rRh634Y6QtoqkwTTrGzX66UYoCAvgE6jL",
            "RootIndex": "ABD8CE2D1205D0C062876E9E1F3CBDC902ED8EF4E8D3D071B962C7ED0E113E68"
          },
          "LedgerEntryType": "DirectoryNode",
          "LedgerIndex": "0BBDEE7D0BE120F7BF27640B5245EBFE0C5FD5281988BA823C44477A70262A4D"
        }
      },
      {
        "DeletedNode": {
          "FinalFields": {
            "Account": "rRh634Y6QtoqkwTTrGzX66UYoCAvgE6jL",
            "BookDirectory": "892E892DC63D8F70DCF5C9ECF29394FF7DD3DC6F47DB8EB34A03920BFC5E99BE",
            "BookNode": "0000000000000000",
            "Flags": 0,
            "OwnerNode": "000000000000006E",
            "PreviousTxnID": "58A17D95770F8D07E08B81A85896F4032A328B6C2BDCDEC0A00F3EF3914DCF0A",
            "PreviousTxnLgrSeq": 7125330,
            "Sequence": 540691,
            "TakerGets": "4401967683",
            "TakerPays": {
              "currency": "BTC",
              "issuer": "rNPRNzBB92BVpAhhZr4iXDTveCgV5Pofm9",
              "value": "0.04424"
            }
          },
          "LedgerEntryType": "Offer",
          "LedgerIndex": "386B7803A9210747941B0D079BB408F31ACB1CB98832184D0287A1CBF4FE6D00"
        }
      },
      {
        "DeletedNode": {
          "FinalFields": {
            "ExchangeRate": "4A03920BFC5E99BE",
            "Flags": 0,
            "RootIndex": "892E892DC63D8F70DCF5C9ECF29394FF7DD3DC6F47DB8EB34A03920BFC5E99BE",
            "TakerGetsCurrency": "0000000000000000000000000000000000000000",
            "TakerGetsIssuer": "0000000000000000000000000000000000000000",
            "TakerPaysCurrency": "0000000000000000000000004254430000000000",
            "TakerPaysIssuer": "92D705968936C419CE614BF264B5EEB1CEA47FF4"
          },
          "LedgerEntryType": "DirectoryNode",
          "LedgerIndex": "892E892DC63D8F70DCF5C9ECF29394FF7DD3DC6F47DB8EB34A03920BFC5E99BE"
        }
      },
      {
        "ModifiedNode": {
          "FinalFields": {
            "Account": "rRh634Y6QtoqkwTTrGzX66UYoCAvgE6jL",
            "Balance": "11133297300",
            "Flags": 0,
            "OwnerCount": 9,
            "Sequence": 540706
          },
          "LedgerEntryType": "AccountRoot",
          "LedgerIndex": "A6C2532E1008A513B3F822A92B8E5214BD0D413DC20AD3631C1A39AD6B36CD07",
          "PreviousFields": {
            "Balance": "11133297310",
            "OwnerCount": 10,
            "Sequence": 540705
          },
          "PreviousTxnID": "484D57DFC4E446DA83B4540305F0CE836D4E007361542EC12CC0FFB5F0A1BE3A",
          "PreviousTxnLgrSeq": 7125358
        }
      }
    ],
    "TransactionIndex": 1,
    "TransactionResult": "tesSUCCESS"
  },
  "transaction": {
    "Account": "rRh634Y6QtoqkwTTrGzX66UYoCAvgE6jL",
    "Fee": "10",
    "Flags": 2147483648,
    "OfferSequence": 540691,
    "Sequence": 540705,
    "SigningPubKey": "030BB49C591C9CD65C945D4B78332F27633D7771E6CF4D4B942D26BA40748BB8B4",
    "TransactionType": "OfferCancel",
    "TxnSignature": "30450221008223604A383F3AED25D53CE7C874700619893A6EEE4336508312217850A9722302205E0614366E174F2DFF78B879F310DB0B3F6DA1967E52A32F65E25DCEC622CD68",
    "date": 455751680,
    "hash": "94CF924C774DFDBE474A2A7E40AEA70E7E15D130C8CBEF8AF1D2BE97A8269F14"
  },
  "validated": true
}
</code></pre>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>String</td>
<td><code>transaction</code> indicates this is the notification of a transaction, which could come from the <code>transactions</code> or <code>transactions_proposed</code> streams, or from watching a particular account</td>
</tr>
<tr>
<td>engine_result</td>
<td>String</td>
<td>String <a href="transactions.html#result-categories">Transaction result code</a></td>
</tr>
<tr>
<td>engine_result_code</td>
<td>Number</td>
<td>Numeric <a href="transactions.html#result-categories">transaction response code</a>, if applicable.</td>
</tr>
<tr>
<td>engine_result_message</td>
<td>String</td>
<td>Human-readable explanation for the transaction response</td>
</tr>
<tr>
<td>ledger_current_index</td>
<td>Unsigned Integer</td>
<td>(Omitted for validated transactions) Sequence number of the current ledger version for which this transaction is currently proposed</td>
</tr>
<tr>
<td>ledger_hash</td>
<td>String</td>
<td>(Omitted for unvalidated transactions) Unique hash of the ledger version that includes this transaction, as hex</td>
</tr>
<tr>
<td>ledger_index</td>
<td>Unsigned Integer</td>
<td>(Omitted for unvalidated transactions) Sequence number of the ledger version that includes this transaction</td>
</tr>
<tr>
<td>meta</td>
<td>Object</td>
<td>(Omitted for unvalidated transactions) Various metadata about the transaction, including which ledger entries it affected</td>
</tr>
<tr>
<td>transaction</td>
<td>Object</td>
<td>The <a href="transactions.html">definition of the transaction</a> in JSON format</td>
</tr>
<tr>
<td>validated</td>
<td>Boolean</td>
<td>If true, this transaction is included in a validated ledger. Responses from the <code>transaction</code> stream should always be validated.</td>
</tr>
</tbody>
</table>
<h2 id="unsubscribe">unsubscribe</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/Unsubscribe.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>unsubscribe</code> command tells the server to stop sending messages for a particular subscription or set of subscriptions.</p>
<h4 id="request-format-28">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:129


</div>
<p><a class="button" href="ripple-api-tool.html#unsubscribe">Try it! &gt;</a></p>
<p>The parameters in the request are specified almost exactly like the parameters to <a href="#subscribe"><code>subscribe</code></a>, except that they are used to define which subscriptions to end instead. The parameters are:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>streams</td>
<td>Array</td>
<td>(Optional) Array of string names of generic streams to unsubscribe from, including <code>ledger</code>, <code>server</code>, <code>transactions</code>, and <code>transactions_proposed</code>.</td>
</tr>
<tr>
<td>accounts</td>
<td>Array</td>
<td>(Optional) Array of unique base-58 account addresses to stop receiving updates for. (This only stops those messages if you previously subscribed to those accounts specifically. You cannot use this to filter accounts out of the general transactions stream.)</td>
</tr>
<tr>
<td>accounts_proposed</td>
<td>Array</td>
<td>(Optional) Like <code>accounts</code>, but for <code>accounts_proposed</code> subscriptions that included not-yet-validated transactions.</td>
</tr>
<tr>
<td>books</td>
<td>Array</td>
<td>(Optional) Array of objects defining order books to unsubscribe from, as explained below.</td>
</tr>
</tbody>
</table>
<p>The <code>rt_accounts</code> and <code>url</code> parameters, and the <code>rt_transactions</code> stream name, are deprecated and may be removed without further notice.</p>
<p>The objects in the <code>books</code> array are defined almost like the ones from subscribe, except that they don't have all the fields. The fields they have are as follows:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>taker_gets</td>
<td>Object</td>
<td>Specification of which currency the account taking the offer would receive, as an object with <code>currency</code> and <code>issuer</code> fields (omit issuer for XRP), similar to <a href="#specifying-currency-amounts">currency amounts</a>.</td>
</tr>
<tr>
<td>taker_pays</td>
<td>Object</td>
<td>Specification of which currency the account taking the offer would pay, as an object with <code>currency</code> and <code>issuer</code> fields (omit issuer for XRP), similar to <a href="#specifying-currency-amounts">currency amounts</a>.</td>
</tr>
<tr>
<td>both</td>
<td>Boolean</td>
<td>(Optional, defaults to false) If true, remove a subscription for both sides of the order book.</td>
</tr>
</tbody>
</table>
<h4 id="response-format-27">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:130


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing no fields.</p>
<h4 id="possible-errors-27">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li><code>noPermission</code> - The request included the <code>url</code> field, but you are not connected as an admin.</li>
<li><em>Unknown Stream</em> - One or more the members of the <code>streams</code> field in the request was not recognized as a valid stream name. (The response does not use an exact code; this is a bug. See <a href="https://ripplelabs.atlassian.net/browse/RIPD-702">RIPD-702</a> for details and status.)</li>
<li><code>malformedStream</code> - The <code>streams</code> field of the request was not formatted properly.</li>
<li><code>malformedAccount</code> - One of the addresses in the <code>accounts</code> or <code>accounts_proposed</code> fields of the request is not a properly-formatted Ripple address. (<strong><em>Note</em></strong>: You <em>can</em> subscribe to the stream of an address that does not yet have an entry in the global ledger; if your subscription is still active, you will get a message when that account receives the payment that creates it.)</li>
<li><code>srcCurMalformed</code> - One or more <code>taker_pays</code> sub-fields of the <code>books</code> field in the request is not formatted properly.</li>
<li><code>dstAmtMalformed</code> - One or more <code>taker_gets</code> sub-fields of the <code>books</code> field in the request is not formatted properly.</li>
<li><code>srcIsrMalformed</code> - The <code>issuer</code> field of one or more <code>taker_pays</code> sub-fields of the <code>books</code> field in the request is not valid.</li>
<li><code>dstIsrMalformed</code> - The <code>issuer</code> field of one or more <code>taker_gets</code> sub-fields of the <code>books</code> field in the request is not valid.</li>
<li><code>badMarket</code> - One or more desired order books in the <code>books</code> field does not exist; for example, offers to exchange a currency for itself.</li>
</ul>
<h1 id="server-information">Server Information</h1>
<p>There are also commands that retrieve information about the current state of the server. These may be useful for monitoring the health of the server, or in preparing for making other API methods. For example, you may query for the current fee schedule before sending a transaction, or you may check which ledger versions are available before digging into the ledger history for a specific record.</p>
<h2 id="server-info">server_info</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/ServerInfo.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>server_info</code> command asks the server for a human-readable version of various information about the <code>rippled</code> server being queried.</p>
<h4 id="request-format-29">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:131


*JSON-RPC*

wzxhzdk:132


</div>
<p><a class="button" href="ripple-api-tool.html#server_info">Try it! &gt;</a></p>
<p>The request does not takes any parameters.</p>
<h4 id="response-format-28">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:133


*JSON-RPC*

wzxhzdk:134


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing an <code>info</code> object as its only field.</p>
<p>The <code>info</code> object may have some arrangement of the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>build_version</td>
<td>String</td>
<td>The version number of the running <code>rippled</code> version.</td>
</tr>
<tr>
<td>complete_ledgers</td>
<td>String</td>
<td>Range expression indicating the sequence numbers of the ledger versions the local rippled has in its database. It is possible to be a disjoint sequence, e.g. "2500-5000,32570-7695432".</td>
</tr>
<tr>
<td>hostid</td>
<td>String</td>
<td>On an admin request, returns the hostname of the server running the <code>rippled</code> instance; otherwise, returns a unique four letter word.</td>
</tr>
<tr>
<td>io_latency_ms</td>
<td>Number</td>
<td>Amount of time spent waiting for I/O operations to be performed, in milliseconds. If this number is not very, very low, then the <code>rippled</code> server is probably having serious load issues.</td>
</tr>
<tr>
<td>last_close</td>
<td>Object</td>
<td>Information about the last time the server closed a ledger, including the amount of time it took to reach a consensus and the number of trusted validators participating.</td>
</tr>
<tr>
<td>load</td>
<td>Object</td>
<td><em>Admin only</em> Detailed information about the current load state of the server</td>
</tr>
<tr>
<td>load.job_types</td>
<td>Array</td>
<td><em>Admin only</em> Information about the rate of different types of jobs being performed by the server and how much time it spends on each.</td>
</tr>
<tr>
<td>load.threads</td>
<td>Number</td>
<td><em>Admin only</em> The number of threads in the server's main job pool, performing various Ripple Network operations.</td>
</tr>
<tr>
<td>load_factor</td>
<td>Number</td>
<td>The load factor the server is currently enforcing, as a multiplier on the base transaction cost. The load factor is determined by the highest of the individual server's load factor, cluster's load factor, and the overall network's load factor. <strong>Note:</strong> This <code>load_factor</code> is calculated as the ratio of the <code>load_factor</code> and the <code>load_base</code> that are reported by the <a href="#server-state"><code>server_state</code> command</a></td>
</tr>
<tr>
<td>peers</td>
<td>Number</td>
<td>How many other <code>rippled</code> servers the node is currently connected to.</td>
</tr>
<tr>
<td>pubkey_node</td>
<td>String</td>
<td>Public key used to verify this node for internal communications; this key is automatically generated by the server the first time it starts up. (If deleted, the node can just create a new pair of keys.)</td>
</tr>
<tr>
<td>pubkey_validator</td>
<td>String</td>
<td><em>Admin only</em> Public key used by this node to sign ledger validations; .</td>
</tr>
<tr>
<td>server_state</td>
<td>String</td>
<td>A string indicating to what extent the server is participating in the network. See <a href="#possible-server-states">Possible Server States</a> for more details.</td>
</tr>
<tr>
<td>validated_ledger</td>
<td>Object</td>
<td>Information about the fully-validated ledger with the highest sequence number (the most recent)</td>
</tr>
<tr>
<td>validated_ledger.age</td>
<td>Unsigned Integer</td>
<td>The time since the ledger was closed, in seconds</td>
</tr>
<tr>
<td>validated_ledger.base_fee_xrp</td>
<td>Number</td>
<td>Base fee, in XRP. This may be represented in scientific notation such as 1e-05 for 0.00005</td>
</tr>
<tr>
<td>validated_ledger.hash</td>
<td>String</td>
<td>Unique hash for the ledger, as hex</td>
</tr>
<tr>
<td>validated_ledger.reserve_base_xrp</td>
<td>Unsigned Integer</td>
<td>Minimum amount of XRP (not drops) necessary for every account to keep in reserve</td>
</tr>
<tr>
<td>validated_ledger.reserve_inc_xrp</td>
<td>Unsigned Integer</td>
<td>Amount of XRP (not drops) added to the account reserve for each object an account is responsible for in the ledger</td>
</tr>
<tr>
<td>validated_ledger.seq</td>
<td>Unsigned Integer</td>
<td>Identifying sequence number of this ledger version</td>
</tr>
<tr>
<td>validation_quorum</td>
<td>Number</td>
<td>Minimum number of trusted validations required in order to validate a ledger version. Some circumstances may cause the server to require more validations.</td>
</tr>
</tbody>
</table>
<!--Note: keep the above table up-to-date with the Get Server Status method in the Ripple-REST documentation -->
<h4 id="possible-errors-28">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
</ul>
<h2 id="server-state">server_state</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/ServerState.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>server_state</code> command asks the server for various machine-readable information about the <code>rippled</code> server's current state. The results are very similar to <a href="#server-info"><code>server_info</code></a>, but generally the units are chosen to be easier to process instead of easier to read. (For example, XRP values are given in integer drops instead of scientific notation or decimal values, and time is given in milliseconds instead of seconds.)</p>
<h4 id="request-format-30">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:135


*JSON-RPC*

wzxhzdk:136


</div>
<p><a class="button" href="ripple-api-tool.html#server_state">Try it! &gt;</a></p>
<p>The request does not takes any parameters.</p>
<h4 id="response-format-29">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:137


*JSON-RPC*

wzxhzdk:138


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing a <code>state</code> object as its only field.</p>
<p>The <code>state</code> object may have some arrangement of the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>build_version</td>
<td>String</td>
<td>The version number of the running <code>rippled</code> version.</td>
</tr>
<tr>
<td>complete_ledgers</td>
<td>String</td>
<td>Range expression indicating the sequence numbers of the ledger versions the local rippled has in its database. It is possible to be a disjoint sequence, e.g. "2500-5000,32570-7695432".</td>
</tr>
<tr>
<td>io_latency_ms</td>
<td>Number</td>
<td>Amount of time spent waiting for I/O operations to be performed, in milliseconds. If this number is not very, very low, then the <code>rippled</code> server is probably having serious load issues.</td>
</tr>
<tr>
<td>load</td>
<td>Object</td>
<td><em>Admin only</em> Detailed information about the current load state of the server</td>
</tr>
<tr>
<td>load.job_types</td>
<td>Array</td>
<td><em>Admin only</em> Information about the rate of different types of jobs being performed by the server and how much time it spends on each.</td>
</tr>
<tr>
<td>load.threads</td>
<td>Number</td>
<td><em>Admin only</em> The number of threads in the server's main job pool, performing various Ripple Network operations.</td>
</tr>
<tr>
<td>load_base</td>
<td>Number</td>
<td>This amount of server load is the baseline that is used to decide how much to charge in transaction fees; if the <code>load_factor</code> is equal to the <code>load_base</code> then only the base fee is enforced; if the <code>load_factor</code> is double the <code>load_base</code> then transaction fees are doubled.</td>
</tr>
<tr>
<td>load_factor</td>
<td>Number</td>
<td>The load factor the server is currently enforcing. The ratio between this value and the load_base determines the multiplier for transaction fees. The load factor is determined by the highest of the individual server's load factor, cluster's load factor, and the overall network's load factor.</td>
</tr>
<tr>
<td>peers</td>
<td>Number</td>
<td>How many other <code>rippled</code> servers the node is currently connected to.</td>
</tr>
<tr>
<td>pubkey_node</td>
<td>String</td>
<td>Public key used by this server (along with the corresponding private key) for secure communications between nodes. This key pair is automatically created and stored in rippled's local database the first time it starts up; if lost or deleted, a new key pair can be generated with no ill effects.</td>
</tr>
<tr>
<td>pubkey_validator</td>
<td>String</td>
<td><em>Admin only</em> Public key used by this server (along with the corresponding private key) to sign proposed ledgers for validation.</td>
</tr>
<tr>
<td>server_state</td>
<td>String</td>
<td>A string indicating to what extent the server is participating in the network. See <a href="#possible-server-states">Possible Server States</a> for more details.</td>
</tr>
<tr>
<td>validated_ledger</td>
<td>Object</td>
<td>Information about the fully-validated ledger with the highest sequence number (the most recent)</td>
</tr>
<tr>
<td>validated_ledger.base_fee</td>
<td>Unsigned Integer</td>
<td>Base fee, in drops of XRP, for propagating a transaction to the network.</td>
</tr>
<tr>
<td>validated_ledger.close_time</td>
<td>Number</td>
<td>Time this ledger was closed, in seconds since the <a href="#specifying-time">Ripple Epoch</a></td>
</tr>
<tr>
<td>validated_ledger.hash</td>
<td>String</td>
<td>Unique hash of this ledger version, as hex</td>
</tr>
<tr>
<td>validated_ledger.reserve_base</td>
<td>Unsigned Integer</td>
<td>Minimum amount, in drops of XRP, necessary for every account to keep in reserve</td>
</tr>
<tr>
<td>validated_ledger.reserve_inc</td>
<td>Unsigned Integer</td>
<td>Amount, in drops of XRP, that is added to the account reserve for each item the account owns in the ledger.</td>
</tr>
<tr>
<td>validated_ledger.seq</td>
<td>Unsigned Integer</td>
<td>Unique sequence number of this ledger</td>
</tr>
<tr>
<td>validation_quorum</td>
<td>Number</td>
<td>Minimum number of trusted validations required in order to validate a ledger version. Some circumstances may cause the server to require more validations.</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-29">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
</ul>
<h2 id="can-delete">can_delete</h2>
<p><a href="https://github.com/ripple/rippled/blob/develop/src/ripple/rpc/handlers/CanDelete.cpp" title="Source">[Source]<br/></a></p>
<p>With <code>online_delete</code> and <code>advisory_delete</code> configuration options enabled, the <code>can_delete</code> method informs the rippled server of the latest ledger which may be deleted. </p>
<p><em>The <code>can_delete</code> method is an admin command that cannot be run by unpriviledged users.</em></p>
<h4 id="request-format-31">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:139


*JSON-RPC*

wzxhzdk:140


*Commandline*

wzxhzdk:141


</div>
<p>The request includes the following optional parameter:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>can_delete</td>
<td>String or Integer</td>
<td>The maximum ledger to allow to be deleted. For <code>ledger_index</code> or <code>ledger_hash</code>, see <a href="#specifying-a-ledger-instance">Specifying a Ledger</a>. <code>never</code> sets the value to 0, and effectively disables online deletion until another <code>can_delete</code> is appropriately called.  <code>always</code> sets the value to the maximum possible ledger (4294967295), and online deletion will occur as of each configured <code>online_delete</code> interval. <code>now</code> triggers online deletion at the next validated ledger that meets or exceeds the configured <code>online_delete</code> interval, but no further.</td>
</tr>
</tbody>
</table>
<p>If no parameter is specified, no change is made.</p>
<p>The response follows the <a href="#response-formatting">standard format</a>, with
a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>can_delete</td>
<td>Integer</td>
<td>The maximum ledger index that may be removed by the online deletion routine.</td>
</tr>
</tbody>
</table>
<p>Use this command with no parameter to query the existing <code>can_delete</code> setting.</p>
<h4 id="possible-errors-30">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>notEnabled</code> - Not enabled in configuration.</li>
<li><code>notReady</code> - Not ready to handle this request.</li>
<li><code>lgrNotFound</code> - Ledger not found.</li>
<li><code>invalidParams</code> - Invalid parameters.</li>
</ul>
<h2 id="consensus-info">consensus_info</h2>
<p><a href="https://github.com/ripple/rippled/blob/a61ffab3f9010d8accfaa98aa3cacc7d38e74121/src/ripple/rpc/handlers/ConsensusInfo.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>consensus_info</code> command provides information about the consensus process for debugging purposes.</p>
<p><em>The <code>consensus_info</code> method is an admin command that cannot be run by unpriviledged users.</em></p>
<h4 id="request-format-32">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:142


*JSON-RPC*


wzxhzdk:143


*Commandline*


wzxhzdk:144


</div>
<p>The request has no parameters.</p>
<h4 id="response-format-30">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*JSON-RPC*


wzxhzdk:145


*Commandline*


wzxhzdk:146


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>info</td>
<td>Object</td>
<td>Information that may be useful for debugging consensus. This output is subject to change without notice.</td>
</tr>
</tbody>
</table>
<p>The following is an incomplete summary of fields that may be contained in the <code>info</code> object:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ledger_seq</td>
<td>Number</td>
<td>The sequence number of the ledger currently in the consensus process</td>
</tr>
<tr>
<td>our_position</td>
<td>Object</td>
<td>This server's expectation for the ledger in the consensus process.</td>
</tr>
<tr>
<td>peer_positions</td>
<td>Object</td>
<td>Map of peers and their proposed versions of the ledger in the consensus process.</td>
</tr>
<tr>
<td>proposers</td>
<td>Number</td>
<td>The number of trusted validators participating in this consensus process. Which validators are trusted depends on this server's configuration.</td>
</tr>
<tr>
<td>synched</td>
<td>Boolean</td>
<td>Whether this server considers itself in sync with the network.</td>
</tr>
<tr>
<td>state</td>
<td>String</td>
<td>What portion of the consensus process is currently in progress: <code>open</code>, <code>consensus</code>, <code>finished</code>, or <code>accepted</code>.</td>
</tr>
</tbody>
</table>
<p>It is also normal to get a minimal result where the only field in <code>info</code> is <code>"consensus": "none"</code>. This indicates that the server is in between consensus rounds. </p>
<p>The results of the <code>consensus_info</code> command can vary dramatically if you run it several times, even in short succession.</p>
<h4 id="possible-errors-31">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
</ul>
<h2 id="fetch-info">fetch_info</h2>
<p><a href="https://github.com/ripple/rippled/blob/315a8b6b602798a4cff4d8e1911936011e12abdb/src/ripple/rpc/handlers/FetchInfo.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>fetch_info</code> command returns information about objects that this server is currently fetching from the network, and how many peers have that information. It can also be used to reset current fetches. </p>
<p><em>The <code>fetch_info</code> method is an admin command that cannot be run by unpriviledged users.</em></p>
<h4 id="request-format-33">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:147


*JSON-RPC*


wzxhzdk:148


*Commandline*


wzxhzdk:149


</div>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>clear</td>
<td>Boolean</td>
<td>If <code>true</code>, reset current fetches. Otherwise, only get status of fetches in progress.</td>
</tr>
</tbody>
</table>
<h4 id="response-format-31">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*JSON-RPC*


wzxhzdk:150


*Commandline*


wzxhzdk:151


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>info</td>
<td>Object</td>
<td>Map of objects being fetched and the status of that object being fetched. A ledger being fetched may be identified by its sequence number; ledgers and other objects being fetched may also be identified by their hashes.</td>
</tr>
</tbody>
</table>
<p>The fields describing a fetch in progress are subject to change without notice. The following fields may be included:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td>String</td>
<td>The hash of the object being fetched.</td>
</tr>
<tr>
<td>have_header</td>
<td>Boolean</td>
<td>For a ledger, whether this server has already obtained the ledger's header section.</td>
</tr>
<tr>
<td>have_transactions</td>
<td>Boolean</td>
<td>For a ledger, whether this server has already obtained the transaction section of that ledger.</td>
</tr>
<tr>
<td>needed_state_hashes</td>
<td>Array of (Hash) Strings</td>
<td>The hash values of state nodes still needed from this object. If more than 16 are needed, the response contains only the first 16.</td>
</tr>
<tr>
<td>peers</td>
<td>Number</td>
<td>The number of peers who have this object available.</td>
</tr>
<tr>
<td>timeouts</td>
<td>Number</td>
<td>The number of times that fetching this object has resulted in a timeout (2.5 seconds).</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-32">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
</ul>
<h2 id="get-counts">get_counts</h2>
<p><a href="https://github.com/ripple/rippled/blob/c7118a183a660648aa88a3546a6b2c5bce858440/src/ripple/rpc/handlers/GetCounts.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>get_counts</code> command provides various stats about the health of the server, mostly the number of objects of different types that it currently holds in memory. </p>
<p><em>The <code>get_counts</code> method is an admin command that cannot be run by unpriviledged users.</em></p>
<h4 id="request-format-34">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:152


*JSON-RPC*


wzxhzdk:153


*Commandline*


wzxhzdk:154


</div>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>min_count</td>
<td>Number (Unsigned Integer)</td>
<td>Only return fields with a value at least this high.</td>
</tr>
</tbody>
</table>
<h4 id="response-format-32">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*JSON-RPC*


wzxhzdk:155


*Commandline*


wzxhzdk:156


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>. The list of fields contained in the result is subject to change without notice, but it may contain any of the following (among others):</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Transaction</td>
<td>Number</td>
<td>The number of <code>Transaction</code> objects in memory</td>
</tr>
<tr>
<td>Ledger</td>
<td>Number</td>
<td>The number of ledgers in memory</td>
</tr>
<tr>
<td>uptime</td>
<td>String</td>
<td>The amount of time this server has been running uninterrupted.</td>
</tr>
</tbody>
</table>
<p>For most other entries, the value indicates the number of objects of that type currently in memory.</p>
<h4 id="possible-errors-33">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
</ul>
<h2 id="ledger-cleaner">ledger_cleaner</h2>
<p><a href="https://github.com/ripple/rippled/blob/df54b47cd0957a31837493cd69e4d9aade0b5055/src/ripple/rpc/handlers/LedgerCleaner.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>ledger_cleaner</code> command controls the <a href="https://github.com/ripple/rippled/blob/f313caaa73b0ac89e793195dcc2a5001786f916f/src/ripple/app/ledger/README.md#the-ledger-cleaner">Ledger Cleaner</a>, an asynchronous maintenance process that can find and repair corruption in rippled's database of ledgers. </p>
<p><em>The <code>ledger_cleaner</code> method is an admin command that cannot be run by unpriviledged users.</em></p>
<h4 id="request-format-35">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:157


</div>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ledger</td>
<td>Number (Ledger Sequence Number)</td>
<td>(Optional) If provided, check and correct this specific ledger only.</td>
</tr>
<tr>
<td>max_ledger</td>
<td>Number (Ledger Sequence Number)</td>
<td>(Optional) Configure the ledger cleaner to check ledgers with sequence numbers equal or lower than this.</td>
</tr>
<tr>
<td>min_ledger</td>
<td>Number (Ledger Sequence Number)</td>
<td>(Optional) Configure the ledger cleaner to check ledgers with sequence numbers equal or higher than this.</td>
</tr>
<tr>
<td>full</td>
<td>Boolean</td>
<td>(Optional) If true, fix ledger state nodes and transations in the specified ledger(s). Defaults to false. Automatically set to <code>true</code> if <code>ledger</code> is provided.</td>
</tr>
<tr>
<td>fix_txns</td>
<td>Boolean</td>
<td>(Optional) If true, correct transaction in the specified ledger(s). Overrides <code>full</code> if provided.</td>
</tr>
<tr>
<td>check_nodes</td>
<td>Boolean</td>
<td>(Optional) If true, correct ledger state nodes in the specified ledger(s). Overrides <code>full</code> if provided.</td>
</tr>
<tr>
<td>stop</td>
<td>Boolean</td>
<td>(Optional) If true, disable the ledger cleaner.</td>
</tr>
</tbody>
</table>
<h4 id="response-format-33">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*JSON-RPC*


wzxhzdk:158


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>message</td>
<td>String</td>
<td><code>Cleaner configured</code> on success.</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-34">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>internal</code> if one the parameters was specified in a way that the server couldn't interpret. (This is a bug, and it should return <code>invalidParams</code> instead. See <a href="https://ripplelabs.atlassian.net/browse/RIPD-916">RPD-916</a> for status.)</li>
</ul>
<h2 id="log-level">log_level</h2>
<p><a href="https://github.com/ripple/rippled/blob/155fcdbcd0b4927152892c8c8be01d9cf62bed68/src/ripple/rpc/handlers/LogLevel.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>log_level</code> command changes the <code>rippled</code> server's logging verbosity, or returns the current logging level for each category (called a <em>partition</em>) of log messages.</p>
<p><em>The <code>log_level</code> method is an admin command that cannot be run by unpriviledged users.</em></p>
<h4 id="request-format-36">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:159


*Commandline*


wzxhzdk:160


</div>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>severity</td>
<td>String</td>
<td>(Optional) What level of verbosity to set logging at. Valid values are, in order from least to most verbose: <code>fatal</code>, <code>error</code>, <code>warn</code>, <code>info</code>, <code>debug</code>, and <code>trace</code>. If omitted, return current log verbosity for all categories.</td>
</tr>
<tr>
<td>partition</td>
<td>String</td>
<td>(Optional) Ignored unless <code>severity</code> is provided. Which logging category to modify. If omitted, or if provided with the value <code>base</code>, set logging level for all categories.</td>
</tr>
</tbody>
</table>
<h4 id="response-format-34">Response Format</h4>
<p>Examples of successful responses:</p>
<div class="multicode">

*Commandline (set log level)*


wzxhzdk:161


*Commandline (check log levels)*


wzxhzdk:162


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>. The response format depends on whether the request specified a <code>severity</code>. If it did, the log level is changed and a successful result contains no additional fields. </p>
<p>Otherwise, the request contains the following field:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>level</td>
<td>Object</td>
<td>The current log levels of each category. This list of categories is subject to change without notice in future releases. You can use the field names as values to <code>partition</code> in requests to this command.</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-35">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
</ul>
<h2 id="logrotate">logrotate</h2>
<p><a href="https://github.com/ripple/rippled/blob/743bd6c9175c472814448ea889413be79dfd1c07/src/ripple/rpc/handlers/LogRotate.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>logrotate</code> command closes and reopens the log file. This is intended to facilitate log rotation on Linux file systems.</p>
<p><em>The <code>logrotate</code> method is an admin command that cannot be run by unpriviledged users.</em></p>
<h4 id="request-format-37">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:163


*Commandline*


wzxhzdk:164


</div>
<p>The request includes no parameters.</p>
<h4 id="response-format-35">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*JSON-RPC*


wzxhzdk:165


*Commandline*


wzxhzdk:166


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>message</td>
<td>String</td>
<td>On success, contains the message <code>The log file was closed and reopened.</code></td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-36">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
</ul>
<h2 id="validation-create">validation_create</h2>
<p><a href="https://github.com/ripple/rippled/blob/315a8b6b602798a4cff4d8e1911936011e12abdb/src/ripple/rpc/handlers/ValidationCreate.cpp" title="Source">[Source]<br/></a></p>
<p>Use the <code>validation_create</code> command to generate the keys for a rippled <a href="rippled-setup.html#validator-setup">validating node</a>. Similar to the <a href="#wallet-propose">wallet_propose</a> command, this command makes no real changes, but only generates a set of keys in the proper format.</p>
<p><em>The <code>validation_create</code> method is an admin command that cannot be run by unpriviledged users.</em></p>
<h4 id="request-format-38">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:167


*JSON-RPC*


wzxhzdk:168


*Commandline*


wzxhzdk:169


</div>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>secret</td>
<td>String</td>
<td>(Optional) Use this value as a seed to generate the credentials. The same secret always generates the same credentials. You can provide the seed in <a href="https://tools.ietf.org/html/rfc1751">RFC-1751</a> format or Ripple's base-58 format. If omitted, generate a random seed.</td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong> The security of your validator depends on the entropy of your seed. Do not use a secret value that is not sufficiently randomized for real business purposes. We recommend omitting the <code>secret</code> when generating new credentials for the first time.</p>
<h4 id="response-format-36">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*JSON-RPC*


wzxhzdk:170


*Commandline*


wzxhzdk:171


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>validation_key</td>
<td>String</td>
<td>The secret key for these validation credentials, in <a href="https://tools.ietf.org/html/rfc1751">RFC-1751</a> format.</td>
</tr>
<tr>
<td>validation_public_key</td>
<td>String</td>
<td>The public key for these validation credentials, in Ripple's base-58 encoded string format.</td>
</tr>
<tr>
<td>validation_seed</td>
<td>String</td>
<td>The secret key for these validation credentials, in Ripple's base-58 encoded string format.</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-37">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>badSeed</code> - The request provided an invalid seed value. This usually means that the seed value appears to be a valid string of a different format, such as an account address or validation public key.</li>
</ul>
<h2 id="validation-seed">validation_seed</h2>
<p><a href="https://github.com/ripple/rippled/blob/a61ffab3f9010d8accfaa98aa3cacc7d38e74121/src/ripple/rpc/handlers/ValidationSeed.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>validation_seed</code> command temporarily sets the secret value that rippled uses to sign validations. This value resets based on the config file when you restart the server.</p>
<p><em>The <code>validation_seed</code> request is an admin command that cannot be run by unpriviledged users!</em></p>
<h4 id="request-format-39">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:172


*Commandline*


wzxhzdk:173


</div>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>secret</td>
<td>String</td>
<td>(Optional) If present, use this value as the secret value for the validating key pair. Valid formats include base-58, <a href="https://tools.ietf.org/html/rfc1751">RFC-1751</a>, or as a passphrase. If omitted, disables proposing validations to the network.</td>
</tr>
</tbody>
</table>
<h4 id="response-format-37">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*JSON-RPC*


wzxhzdk:174


*Commandline*


wzxhzdk:175


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>validation_key</td>
<td>String</td>
<td>(Omitted if proposing disabled) The secret key for these validation credentials, in <a href="https://tools.ietf.org/html/rfc1751">RFC-1751</a> format.</td>
</tr>
<tr>
<td>validation_public_key</td>
<td>String</td>
<td>(Omitted if proposing disabled) The public key for these validation credentials, in Ripple's base-58 encoded string format.</td>
</tr>
<tr>
<td>validation_seed</td>
<td>String</td>
<td>(Omitted if proposing disabled) The secret key for these validation credentials, in Ripple's base-58 encoded string format.</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-38">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>badSeed</code> - The request provided an invalid secret value. This usually means that the secret value appears to be a valid string of a different format, such as an account address or validation public key.</li>
</ul>
<h2 id="peers">peers</h2>
<p><a href="https://github.com/ripple/rippled/blob/52f298f150fc1530d201d3140c80d3eaf781cb5f/src/ripple/rpc/handlers/Peers.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>peers</code> command returns a list of all other <code>rippled</code> servers currently connected to this one, including information on their connection and sync status.</p>
<p><em>The <code>peers</code> request is an admin command that cannot be run by unpriviledged users!</em></p>
<h4 id="request-format-40">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:176


*Commandline*


wzxhzdk:177


</div>
<p>The request includes no additional parameters.</p>
<h4 id="response-format-38">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*JSON-RPC*


wzxhzdk:178


*Commandline*


wzxhzdk:179


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing a <code>peers</code> array. Each member of the peers array is a peer object with the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>address</td>
<td>String</td>
<td>The IP address and port where this peer is connected</td>
</tr>
<tr>
<td>cluster</td>
<td>Boolean</td>
<td>(May be omitted) If <code>true</code>, the current server and the peer server are part of the same <code>rippled</code> cluster.</td>
</tr>
<tr>
<td>name</td>
<td>String</td>
<td>(May be omitted) If the peer is part of the same cluster, this is the display name for that node as defined in the config file.</td>
</tr>
<tr>
<td>complete_ledgers</td>
<td>String</td>
<td>Range expression indicating the sequence numbers of the ledger versions the peer <code>rippled</code> has available</td>
</tr>
<tr>
<td>inbound</td>
<td>Boolean</td>
<td>(May be omitted) If <code>true</code>, the peer is connecting to the local server.</td>
</tr>
<tr>
<td>latency</td>
<td>Number</td>
<td>The network latency to the peer (in milliseconds)</td>
</tr>
<tr>
<td>ledger</td>
<td>String</td>
<td>The hash of the peer's most recently closed ledger</td>
</tr>
<tr>
<td>load</td>
<td>Number</td>
<td>A measure of the amount of load the peer server is putting on the local server. Larger numbers indicate more load. (The units by which load is measured are not formally defined.)</td>
</tr>
<tr>
<td>protocol</td>
<td>String</td>
<td>(May be omitted) The protocol version that the peer is using, if not the same as the local server.</td>
</tr>
<tr>
<td>public_key</td>
<td>String</td>
<td>(May be omitted) A public key that can be used to verify the integrity of the peer's messages. This is not the same key that is used for validations, but it follows the same format.</td>
</tr>
<tr>
<td>sanity</td>
<td>String</td>
<td>(May be omitted) Whether this peer is following the same rules and ledger sequence as the current server. A value of <code>insane</code> probably indicates that the peer is part of a parallel network. The value <code>unknown</code> indicates that the current server is unsure whether the peer is compatible.</td>
</tr>
<tr>
<td>status</td>
<td>String</td>
<td>(May be omitted) The most recent status message from the peer. Could be <code>connecting</code>, <code>connected</code>, <code>monitoring</code>, <code>validating</code>, or <code>shutting</code>.</td>
</tr>
<tr>
<td>version</td>
<td>string</td>
<td>(May be omitted) The <code>rippled</code> version number of the peer server</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-39">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
</ul>
<h2 id="print">print</h2>
<p><a href="https://github.com/ripple/rippled/blob/315a8b6b602798a4cff4d8e1911936011e12abdb/src/ripple/rpc/handlers/Print.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>print</code> command returns the current status of various internal subsystems, including peers, the ledger cleaner, and the resource manager.</p>
<p><em>The <code>print</code> request is an admin command that cannot be run by unpriviledged users!</em></p>
<h4 id="request-format-41">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:180


*Commandline*


wzxhzdk:181


</div>
<p>The request includes no parameters.</p>
<h4 id="response-format-39">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*Commandline*


wzxhzdk:182


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>. Additional fields in the result depend on the internal state of the <code>rippled</code> server. The results of this command are subject to change without notice.</p>
<h4 id="possible-errors-40">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
</ul>
<h1 id="convenience-functions">Convenience Functions</h1>
<p>The rippled server also provides a few simple commands purely for convenience.</p>
<h2 id="ping">ping</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/Ping.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>ping</code> command returns an acknowledgement, so that clients can test the connection status and latency.</p>
<h4 id="request-format-42">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:183


*JSON-RPC*

wzxhzdk:184


*Commandline*

wzxhzdk:185


</div>
<p><a class="button" href="ripple-api-tool.html#ping">Try it! &gt;</a></p>
<p>The request includes no parameters.</p>
<h4 id="response-format-40">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:186


*JSON-RPC*

wzxhzdk:187


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing no fields. The client can measure the round-trip time from request to response as latency.</p>
<h4 id="possible-errors-41">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
</ul>
<h2 id="random">random</h2>
<p><a href="https://github.com/ripple/rippled/blob/master/src/ripple/rpc/handlers/Random.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>random</code> command provides a random number to be used as a source of entropy for random number generation by clients.</p>
<h4 id="request-format-43">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:188


*JSON-RPC*

wzxhzdk:189


*Commandline*

wzxhzdk:190


</div>
<p>The request includes no parameters.</p>
<h4 id="response-format-41">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*

wzxhzdk:191


*JSON-RPC*

wzxhzdk:192


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following field:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>random</td>
<td>String</td>
<td>Random 256-bit hex value.</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-42">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>internal</code> - Some internal error occurred, possibly relating to the random number generator.</li>
</ul>
<h2 id="json">json</h2>
<p>The <code>json</code> method is a proxy to running other commands, and accepts the parameters for the command as a JSON value. It is <em>exclusive to the Commandline client</em>, and intended for cases where the commandline syntax for specifying parameters is inadequate or undesirable. </p>
<h4 id="request-format-44">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*Commandline*

wzxhzdk:193


</div>
<h4 id="response-format-42">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:194


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with whichever fields are appropriate to the type of command made.</p>
<h2 id="connect">connect</h2>
<p><a href="https://github.com/ripple/rippled/blob/a61ffab3f9010d8accfaa98aa3cacc7d38e74121/src/ripple/rpc/handlers/Connect.cpp" title="Source">[Source]<br/></a></p>
<p>The <code>connect</code> command forces the rippled server to connect to a specific peer rippled server.</p>
<p><em>The <code>connect</code> request is an admin command that cannot be run by unpriviledged users!</em></p>
<h4 id="request-format-45">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:195


*JSON-RPC*


wzxhzdk:196



*Commandline*


wzxhzdk:197


</div>
<p>The request includes the following parameters:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ip</td>
<td>String</td>
<td>IP address of the server to connect to</td>
</tr>
<tr>
<td>port</td>
<td>Number</td>
<td>(Optional) Port number to use when connecting. Defaults to 6561.</td>
</tr>
</tbody>
</table>
<h4 id="response-format-43">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*JSON-RPC*


wzxhzdk:198


*Commandline*


wzxhzdk:199


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>message</td>
<td>String</td>
<td>The value <code>connecting</code>, if the command was successful.</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-43">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
<li><code>invalidParams</code> - One or more fields are specified incorrectly, or one or more required fields are missing.</li>
<li>Cannot connect in standalone mode - Network-related commands are disabled in stand-alone mode.</li>
</ul>
<h2 id="stop">stop</h2>
<p><a href="https://github.com/ripple/rippled/blob/develop/src/ripple/rpc/handlers/Stop.cpp" title="Source">[Source]<br/></a></p>
<p>Gracefully shuts down the server.</p>
<p><em>The <code>stop</code> request is an admin command that cannot be run by unpriviledged users!</em></p>
<h4 id="request-format-46">Request Format</h4>
<p>An example of the request format:</p>
<div class="multicode">

*WebSocket*


wzxhzdk:200


*JSON-RPC*


wzxhzdk:201


*Commandline*


wzxhzdk:202


</div>
<p>The request includes no parameters.</p>
<h4 id="response-format-44">Response Format</h4>
<p>An example of a successful response:</p>
<div class="multicode">

*JSON-RPC*


wzxhzdk:203


*Commandline*


wzxhzdk:204


</div>
<p>The response follows the <a href="#response-formatting">standard format</a>, with a successful result containing the following fields:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>message</td>
<td>String</td>
<td><code>ripple server stopping</code> on success.</td>
</tr>
</tbody>
</table>
<h4 id="possible-errors-44">Possible Errors</h4>
<ul>
<li>Any of the <a href="#universal-errors">universal error types</a>.</li>
</ul>
        </div>
    </div>
    </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-3">
		        <h4>Documentation</h4>
			    <ul class="footer_links">
                    <li><a href="paths.html">Paths</a></li>
                    <li><a href="fees.html">Fees (Disambiguation)</a></li>
                    <li><a href="transfer_fees.html">Transfer Fees</a></li>
                    <li><a href="tx-cost.html">Transaction Cost</a></li>
                    <li><a href="fee-voting.html">Fee Voting</a></li>
                    <li><a href="reserves.html">Reserves</a></li>
                    <li><a href="rippled-apis.html">rippled</a></li>
                    <li><a href="rippled-setup.html">rippled Setup</a></li>
                    <li><a href="ripple-rest.html">Ripple-REST</a></li>
                    <li><a href="transactions.html">Transactions</a></li>
                    <li><a href="ripple-ledger.html">Ripple Consensus Ledger</a></li>
                    <li><a href="reliable_tx.html">Reliable Transaction Submission</a></li>
                    <li><a href="gateway_guide.html">Gateway Guide</a></li>
                    <li><a href="historical_data.html">Historical Data API</a></li>
                    <li><a href="charts_api.html">Ripple Charts API</a></li>
                    <li><a href="data_api_v2.html">Ripple Data API v2</a></li>
                    <li><a href="rippleapi.html">RippleAPI</a></li>
			    </ul>
			</div>
			<div class="col-md-3">
			    <h4>Resources</h4>
				<ul class="footer_links">
				    <li><a href="https://ripple.com/press-releases/">Press Center</a></li>
                    <li><a href="https://ripple.com/brand-guidelines/">Brand Use and Guidelines</a></li>
					<li><a href="https://forum.ripple.com/viewforum.php?f=2">Forums</a></li>
					<li><a href="https://ripple.com/category/dev-blog/">Dev Blog</a></li>
				</ul>
			</div>
			<div class="col-md-3">
			    <h4>Ripple Projects</h4>
				<ul class="footer_links">
					<li><a href="https://www.rippletrade.com">Ripple Trade</a>
					<li><a href="https://www.ripplecharts.com">Ripple Charts</a>
					<li><a href="https://ripple.com/graph">Ripple Graph</a>
					<li><a href="http://codius.org/">Codius</a>
				</ul>
			</div>
			<div class="col-md-3">
		        <h4>Ripple Labs</h4>
			    <ul class="footer_links">
				    <li><a href="https://www.ripplelabs.com/wp-content/uploads/2014/10/ripple_labs_bylaws.pdf">Corporate Bylaws</a></li>
                    <li><a href="https://www.ripplelabs.com/wp-content/uploads/2014/09/ripple_labs_code_of_conduct1.pdf">Code of Conduct</a></li>
                    <li><a href="https://www.ripplelabs.com/team/">Team</a></li>
                    <li><a href="https://www.ripplelabs.com/careers/">Careers</a></li>
                    <li><a href="https://www.ripplelabs.com/investors/">Investors</a></li>
                    <li><a href="https://www.ripplelabs.com/advisors/">Advisors</a></li>
                    <li><a href="https://www.ripplelabs.com/xrp-distribution/">XRP Distribution</a></li>
                    <li><a href="https://www.ripplelabs.com/contact/">Contact</a></li>
			    </ul>
      		</div>
        </div>
    </div>
</footer>
</body>
</html>
